<!DOCTYPE html><html><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>[Go]A Tour of Goのエクササイズをやってみた | アペフチ</title><script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script><link href="../../components/elements.vulcanized.html" rel=import /><link rel=alternate type="application/atom+xml" title="アペフチ" href="../../recent-days.atom"/><link href="../../bower_components/sanitize-css/sanitize.css" rel=stylesheet /><link href="../../stylesheets/highlight-81ca03d6.css" rel=stylesheet /><script src="../../javascripts/all-d7c52391.js"></script><link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="../../images/favicon-8d71db77.png" rel=icon type="image/png" size=60x60 /><link href="/apehuci/manifest.json" rel=manifest><meta name=theme-color content="#b71c1c"><meta name=og:title content="[Go]A Tour of GoのエクササイズをやってみたA Tour of Goのエクササイズをやってみた"><meta name=twitter:description content="A Tour of Goのエクササイズをやって、GitHubに上げてみた：github.com/KitaitiMakoto/a-tour-of-go-exercises。 ウェブクローラーの課題（exercise-web-crawler.go）が難しくて、まずgoroutineを使って非同期にクロールさせるのに手こずった。一つのHTTPリクエストに一つのgor..."><meta name=twitter:card content=summary><meta name=twitter:site content=@KitaitiMakoto><meta name=twitter:image content="https://kitaitimakoto.github.io/apehuci/images/icon-bbe8ac52.png"></head><body class="x2016 x2016_02 x2016_02_21"><blog-router base-regex="^/apehuci/"></blog-router><main><app-header-layout><app-header fixed shadow slot=header><app-toolbar><h2 class=site-title><a href="../../"> アペフチ <paper-ripple></paper-ripple></a></h2></app-toolbar></app-header><article><header><paper-card><h1>A Tour of Goのエクササイズをやってみた</h1><time pubdate>2016-02-21</time><ul class=tags><li><a href="../../tags/go.html" rel=tag>Go</a></li></ul></paper-card></header><paper-card><p><a href="https://tour.golang.org/">A Tour of Go</a>のエクササイズをやって、GitHubに上げてみた：<a href="https://github.com/KitaitiMakoto/a-tour-of-go-exercises">github.com/KitaitiMakoto/a-tour-of-go-exercises</a>。</p><p>ウェブクローラーの課題（<a href="https://github.com/KitaitiMakoto/a-tour-of-go-exercises/blob/master/exercise-web-crawler.go">exercise-web-crawler.go</a>）が難しくて、まずgoroutineを使って非同期にクロールさせるのに手こずった。一つのHTTPリクエストに一つのgoroutineを割り当てた時、終了の待ち合わせはどうするのがいいんだろう。僕は、一々チャンネルを閉じるようにした。閉じるのの待ち合わせは</p><div class="language-go highlighter-rouge"><pre class=highlight><code><span class="k">for</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">ch</span><span class="x"> </span><span class="p">{}</span><span class="x">
</span></code></pre></div><p>とやった。この他に、<code class=highlighter-rouge>go</code>呼び出しの辺りにラベルを付けて、groutineから戻ったところで<code class=highlighter-rouge>break</code>するというやり方もあるようだ。エクササイズは本当は教師がいて答え合わせしてもらえるととてもいいのだけど、残念ながらいないので、誰か、「こうしたらもっといいよ」というの教えてください。まあ、色んなソースを読むというのが、よいのだろうとは思うが。</p><p>次に、「一度フェッチしたURIは二度フェッチしないようにする」というのも課題の一部で、ヒントに「その管理にマップを使うのはいいけど、マップは単独では並行処理に関して安全ではない」とあって、この排他制御にもちょっと困った。大きなロックを獲得して、その中でフェッチすると、並行処理させている意味が無くなっちゃう。でも、どのタイミングでロックを取ればいいのか、何のロックを取ればいいのか、というのに迷った。「一つのURIにつき一つのミューテックスを作る」ということを最初考えたのだけど、そもそもあるURIに対応するミューテックスが存在するかの確認処理と、その後ミューテックスを作るまでの間に他のgoroutineが同じ物を触る可能性があるわけで、うまくいかない。結局、単純にマップその物をロックするようにした。そうすると、<code class=highlighter-rouge>defer</code>を使わない実装になってしまったのだけど、もっといいやり方がないものだろうか。</p></paper-card><footer><ul><li class=next><a href="26.html" rel=next><paper-button raised>Groongaでできる検索方法あれこれ</paper-button></a></li><li class=prev><a href="15.html" rel=prev><paper-button raised>Sendagaya.rb #137</paper-button></a></li></ul><paper-card><blog-search url="https://search.apehuci.kitaitimakoto.net/d" base=/apehuci/ table=Apehuci debounce-duration=300></blog-search></paper-card><paper-card> &copy; <a class=copy href="https://twitter.com/KitaitiMakoto">北市真</a></paper-card></footer></article></app-header-layout></main><script defer async src="//hypothes.is/embed.js"></script><script async="" src="//platform.twitter.com/widgets.js" charset=utf-8></script></body></html>