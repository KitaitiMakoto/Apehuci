<!DOCTYPE html><html><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>[Polymer][pjax]Polymerでpjaxする、またはapp-locationの使い方 | アペフチ</title><script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script><link href="../../components/elements.vulcanized.html" rel=import /><link rel=alternate type="application/atom+xml" title="アペフチ" href="../../recent-days.atom"/><link href="../../bower_components/sanitize-css/sanitize.css" rel=stylesheet /><link href="../../stylesheets/highlight-81ca03d6.css" rel=stylesheet /><script src="../../javascripts/all-d7c52391.js"></script><link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="../../images/favicon-8d71db77.png" rel=icon type="image/png" size=60x60 /><link href="/apehuci/manifest.json" rel=manifest><meta name=theme-color content="#b71c1c"><meta name=og:title content="[Polymer][pjax]Polymerでpjaxする、またはapp-locationの使い方Polymerでpjaxする、またはapp-locationの使い方"><meta name=twitter:description content="この日記はPolymerで作っている、つまりWebコンポーネントを使っている。そのために表示が遅い。表示するまでに Webコンポーネントに必要なpolyfillを読み込む Polymerライブラリーを読み込む 各種カスタムエレメント定義をロードする JavaScriptで各種カスタムエレメント定義を実行する HTML中の各種カスタムエレメントを有効化する とい..."><meta name=twitter:card content=summary><meta name=twitter:site content=@KitaitiMakoto><meta name=twitter:image content="https://kitaitimakoto.github.io/apehuci/images/icon-bbe8ac52.png"></head><body class="x2017 x2017_01 x2017_01_10"><blog-router base-regex="^/apehuci/"></blog-router><main><app-header-layout><app-header fixed shadow slot=header><app-toolbar><h2 class=site-title><a href="../../"> アペフチ <paper-ripple></paper-ripple></a></h2></app-toolbar></app-header><article><header><paper-card><h1>Polymerでpjaxする、またはapp-locationの使い方</h1><time pubdate>2017-01-10</time><ul class=tags><li><a href="../../tags/polymer.html" rel=tag>Polymer</a></li><li><a href="../../tags/pjax.html" rel=tag>pjax</a></li></ul></paper-card></header><paper-card><p>この日記は<a href="https://www.polymer-project.org/1.0/">Polymer</a>で作っている、つまり<a href="http://webcomponents.org/">Webコンポーネント</a>を使っている。そのために表示が遅い。表示するまでに</p><ol><li>Webコンポーネントに必要なpolyfillを読み込む</li><li>Polymerライブラリーを読み込む</li><li>各種カスタムエレメント定義をロードする</li><li>JavaScriptで各種カスタムエレメント定義を実行する</li><li>HTML中の各種カスタムエレメントを有効化する</li></ol><p>というステップがあって、これを毎ページ繰り返すからだ。前々から何とかしたいなあとは思っていて、この連休で、サイト内リンクをpjaxにすることで少し改善させた。</p><p>各ステップはpjaxによって以下のように改善される。</p><h2 id=heading-2017-01-10-table-of-contents>目次</h2><ol><li><a href="#heading-2017-01-10-whats-pjax">pjaxとは</a></li><li><a href="#heading-2017-01-10-loading-polyfill">polyfill読み込み</a></li><li><a href="#heading-2017-01-10-loading-polymer">Polymerライブラリーの読み込み</a></li><li><a href="#heading-2017-01-10-loading-custom-elements">カスタムエレメント読み込み</a></li><li><a href="#heading-2017-01-10-defining-custom-elements">カスタムエレメント定義の実行</a></li><li><a href="#heading-2017-01-10-pjax-using-polymer">Polymerでpjax</a><ol><li><a href="#heading-2017-01-10-app-location">app-location</a></li><li><a href="#heading-2017-01-10-iron-ajax">iron-ajax</a></li></ol></li><li><a href="#heading-2017-01-10-afterwords">終わりに</a></li></ol><h2 id=heading-2017-01-10-whats-pjax>pjaxとは</h2><p>有名なので不要だとは思うけど、一応pjaxを説明しておく。</p><p>pjaxは、</p><ul><li>Ajaxによる画面遷移</li><li><code class=highlighter-rouge>location</code>オブジェクト（アドレスバーのURL）の書き換え</li></ul><p>の組み合わせだ。サイト内の別ページへのリンクをタップした際に、通常のブラウザーの画面遷移をする代わりに、JavaScriptでリンク先のHTMLを取得して、現在のページと置き換える。今回は、<code class=highlighter-rouge>title</code>要素と<code class=highlighter-rouge>main</code>要素を置き換えることで、画面遷移としている。ページ全体でなく、一部の書き換え・更新にもよく使われる。</p><p>同時に<code class=highlighter-rouge>location</code>を書き換えることで、ブラウザーの進む/戻る・リロード、アドレスバーからURLをコピーしての共有など、通常の画面遷移であればできていることを可能にしている。</p><p>後者のためにJavaScriptの<code class=highlighter-rouge>pushState</code>機能を使っていることからpjaxと名付けられている：<br/><a href="https://github.com/defunkt/jquery-pjax">defunkt/jquery-pjax: pushState + ajax = pjax</a></p><p>pjaxは「現在のDOMツリー内での置き換え」が機能なので、外から飛んできて最初に表示するページでは役に立たない。</p><h2 id=heading-2017-01-10-loading-polyfill>polyfill読み込み</h2><p>Webコンポーネントはまだ策定中・ブラウザー実装途中の仕様なので、クロスブラウザーでは動かない。具体的には、Chromeでしか全部は動かない。そこで、他のブラウザーでも動くよう、polyfillやshimを読み込む必要がある。</p><p>これにはWebコンポーネント仕様の一部であるカスタムエレメントなど以外にも、URLコンストラクターやPromiseなどのpolyfillも含まれる。サーバー側でブラウザーの判定などはしていないので（GitHub Pagesなのでそもそもできない）、Chromeのように不要であっても読み込んでいる。</p><p>こういうのは普通、<code class=highlighter-rouge>libs.js</code>のような一つのファイルにまとめることでリクエスト回数を減らすものだけど、面倒くさくて後回しにしている（後回しにするうちにGitHub PagesでHTTP/2が使えるようになるといいなあ、という期待もちょっとある）。</p><p>pjaxによって、<code class=highlighter-rouge>main</code>の外にある<code class=highlighter-rouge>script</code>の読み込みと実行がスキップされるので、パフォーマンスがよくなっている。あと、そもそも同じ<code class=highlighter-rouge>script</code>を二回読み込んだりすると、イベントリスナーの登録が複数回行われたりして意図しない動作になりがちなので、基本的に<code class=highlighter-rouge>script</code>はpjaxでの置き換え対象に入れたくない。</p><h2 id=heading-2017-01-10-loading-polymer>Polymerライブラリーの読み込み</h2><p>ページをPolymerで作っている以上、当然Polymerを読み込む必要がある。</p><p>これもJavaScriptの読み込みなので、上と同じくpjaxによってスキップし、パフォーマンスを向上させている。</p><h2 id=heading-2017-01-10-loading-custom-elements>カスタムエレメント読み込み</h2><p>Polymerが提供していてマテリアルデザインを実現するのに便利な<a href="https://elements.polymer-project.org/browse?package=paper-elements">Paper Elements</a>や自作の物など、各種カスタムエレメントは通常一つのHTMLファイルになっている。その中に、HTMLタグの他CSS宣言や要素定義のJavaScriptを書くようになっているし、僕もそうしている。一つのカスタムエレメントが複数のカスタムエレメントの組み合わせであることもよくあって、依存エレメントの分HTMLを読み込む必要があるのが普通だ。</p><p>先のJavaScriptライブラリーとは違って、これはさすがにリクエストが多くなり過ぎるので<a href="https://github.com/Polymer/vulcanize">vulcanize</a>によって一つのファイルにまとめている。その一つにまとめたHTMLファイルは<code class=highlighter-rouge>head</code>要素中の<code class=highlighter-rouge>link</code>要素</p><div class="language-html highlighter-rouge"><pre class=highlight><code><span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"components/elements.vulcanized.html"</span> <span class="na">rel=</span><span class="s">"import"</span> <span class="nt">/&gt;</span>
</code></pre></div><p>によって読み込んでいる（実際にはこのタグを書き出すヘルパーが<a href="https://github.com/KitaitiMakoto/middleman-web_components">Middleman Web Components</a>にあるので、それを使っている）。</p><p>これも<code class=highlighter-rouge>main</code>要素の外にあるので、pjaxによってスキップしている。</p><h2 id=heading-2017-01-10-defining-custom-elements>カスタムエレメント定義の実行</h2><p>カスタムエレメントは、単にHTML中に<code class=highlighter-rouge>&lt;paper-card&gt;</code>などタグを書くだけでは有効にならない（知らないタグとして扱われる）。このタグがカスタムエレメントの物であることをブラウザーに知らせ、各種機能を定義するにはJavaScriptを使う必要がある（参考：<a href="https://developers.google.com/web/fundamentals/getting-started/primers/customelements">Custom Elements v1: Reusable Web Components</a>）。</p><p>この定義は、上の<code class=highlighter-rouge>elements.vulcanized.html</code>に書かれているので、pjaxによってやはりこのステップもスキップできる。</p><p>これまでのステップは、（HTTPヘッダーやService Workerなどで）キャッシュを上手に使うことでも飛ばせるのだけど、カスタムエレメント定義は、ファイルを読み込んだ<strong>後</strong>の処理なので、ページ遷移ごとに毎回実行する必要があり、キャッシュできない。なのでここが、キャッシュ機構を入れてもなおpjaxが活きるところだと思う。</p><p>本当はpolyfillやPolymer読み込みをキャッシュしても、同様にJavaScript実行はページ表示毎に発生するのだけど、カスタムエレメント定義は特に多くなりがちなので特別に節を設けた。</p><h2 id=heading-2017-01-10-activating-custom-elements>カスタムエレメントの有効化</h2><p>カスタムエレメント定義が終わったらブラウザーは、HTML中のカスタムエレメントタグ（に相当するDOMノード）を、そのカスタムエレメントとして扱い始める。このステップはpjaxではスキップできない。</p><h2 id=heading-2017-01-10-pjax-using-polymer>Polymerでpjax</h2><p>ようやく本題だけど、今回のpjax実装では、Polymerが提供している<a href="https://elements.polymer-project.org/elements/app-route?active=app-location">app-location</a>と<a href="https://elements.polymer-project.org/elements/iron-ajax">iron-ajax</a>というカスタムエレメントを使って実現してみた（<a href="https://github.com/KitaitiMakoto/apehuci/blob/26e1f03ac1a28983faa094b32b98ed1ad4822c26/source/components/blog-router.html">blog-router.html</a>）。pjaxは普通、全部JavaScriptでやるものだと思うけど、半分くらいの処理はHTMLタグを書くことで実現できてしまっていて、不思議な感じがした。</p><h3 id=heading-2017-01-10-app-location>app-location</h3><p><code class=highlighter-rouge>app-location</code>を使うと、サイト内リンクが全部無効化される。その代わり、イベントリスナーでクリックイベントをハンドリングしたり、リンクに関する情報をデータバインディングを使って別の要素に渡したりできる。</p><p>今回は</p><div class="language-html highlighter-rouge"><pre class=highlight><code><span class="nt">&lt;app-location</span> <span class="na">url-space-regex</span><span class="err">$="[[</span><span class="na">baseRegex</span><span class="err">]]"</span> <span class="na">route=</span><span class="s">"{{route}}"</span> <span class="na">id=</span><span class="s">location</span><span class="nt">&gt;&lt;/app-location&gt;</span>
</code></pre></div><p>と<code class=highlighter-rouge>route</code>というオブジェクトに、画面遷移に関する情報を入れることにした。</p><p><code class=highlighter-rouge><span class=p>{</span><span class=err>{...</span><span class=p>}</span><span class=err>}</span></code>はPolymerの提供するデータバインディング用の記法で、他に<code class=highlighter-rouge><span class=p>{</span><span class=err>{route</span><span class=p>}</span><span class=err>}</span></code>と書かれた場所と連動する（<a href="https://www.polymer-project.org/1.0/docs/devguide/data-binding">Data binding - Polymer Project</a>）。</p><h3 id=heading-2017-01-10-iron-ajax>iron-ajax</h3><p><code class=highlighter-rouge>app-location</code>は、アドレスバーのURLの書き換えはしてくれるけど、実際のリクエストは投げてくれない。ので、それをJavaScriptでイベントハンドラーとして書くか、今回のように別の要素と連携させないと意味がない。</p><p><code class=highlighter-rouge>iron-ajax</code>はその名の通りAjaxしてくれるカスタムエレメントで、画面上にレンダリングはされない。純粋にJavaScript的な実行のためにある。これが要素になっているが不思議な感じがする。</p><p>これもデータバインディングの記法を使いつつ</p><div class="language-html highlighter-rouge"><pre class=highlight><code><span class="nt">&lt;iron-ajax</span> <span class="na">url=</span><span class="s">"{{route.path}}"</span> <span class="na">handle-as=</span><span class="s">document</span> <span class="na">auto</span> <span class="na">on-response=</span><span class="s">transit</span> <span class="na">on-error=</span><span class="s">fallback</span> <span class="na">id=</span><span class="s">ajax</span><span class="nt">&gt;&lt;/iron-ajax&gt;</span>
</code></pre></div><p>と書くことで、<code class=highlighter-rouge>app-location</code>の<code class=highlighter-rouge>route</code>オブジェクトから<code class=highlighter-rouge>path</code>プロパティを取り出してセットしている（<code class=highlighter-rouge>path</code>の他に<code class=highlighter-rouge>hash</code>プロパティもあって、本当はこれもちゃんとハンドリングしないといけない）。</p><p><code class=highlighter-rouge>auto</code>属性をつけていると<code class=highlighter-rouge>url</code>属性が変わった際に自動でAjaxが行われるので、</p><div class=highlighter-rouge><pre class=highlight><code>リンクをタップ -&gt; app-locationのroute属性変更 -&gt; iron-ajaxのurl変更 -&gt; Ajaxリクエスト
</code></pre></div><p>という流れをJavaScriptを書かずに実現してくれる（リクエストを間引くのも、使ってないけど、HTML属性によって定義できる）。</p><p>あとはレスポンス時やエラー時の処理をそれぞれ<code class=highlighter-rouge>transit</code>、<code class=highlighter-rouge>fallback</code>という関数としてJavaScriptで書いてやって出来上がりだ。<code class=highlighter-rouge>transit</code>としてJavaScriptで書いた処理は、殆ど<code class=highlighter-rouge>title</code>要素と<code class=highlighter-rouge>main</code>要素の書き換えのみ。</p><h2 id=heading-2017-01-10-afterwords>終わりに</h2><p>Polymerによるpjaxはこのようにして実現できる。これには、公式サイトの以下のページがとても参考になった。</p><p>» <a href="https://www.polymer-project.org/1.0/toolbox/routing">Routing with &lt;app-route&gt; - Polymer Project</a></p><p>余談だけど、<a href="https://github.com/turbolinks/turbolinks">Turbolinks</a>を使うと自分で実装しなくてよかったのかも知れないなと思っている。</p><p>あと、今回、ページ内に一つ<code class=highlighter-rouge>blog-router</code>を置くことによって、つまり一元的なルーターを使ってpjaxを実現している。ReactやAngularでもルーターライブラリーがあるように、この手の処理は一元的なルーターでやるのが普通なのかも知れない。でも、次へリンクなどのHTML要素に結び付く形で、それがpjaxによる遷移かどうかを管理できるようにする、引いては、そのリンクのカスタムエレメントの機能としてpjax処理を実装できた方が、コンポーネント志向としてはいいのかも知れないなあと、やった後で思った。気が向いたらやってみるかも（そして、世界中のみんながルーターを一元的に作っている理由を知るのだ、きっと）。</p><p>今この記事書いてて気付いたけど、ページ内リンクが機能しなくなってしまった……。もう遅いので、後日の対応とします。（追記。直しました。）</p></paper-card><footer><ul><li class=next><a href="../03/13.html" rel=next><paper-button raised>Hypothes.isがEPUBへのアノテーションのためのパートナーシップを結ぶ</paper-button></a></li><li class=prev><a href="08.html" rel=prev><paper-button raised>リポジトリーをGitHubからGitLabに移してみた</paper-button></a></li></ul><paper-card><blog-search url="https://search.apehuci.kitaitimakoto.net/d" base=/apehuci/ table=Apehuci debounce-duration=300></blog-search></paper-card><paper-card> &copy; <a class=copy href="https://twitter.com/KitaitiMakoto">北市真</a></paper-card></footer></article></app-header-layout></main><script defer async src="//hypothes.is/embed.js"></script><script async="" src="//platform.twitter.com/widgets.js" charset=utf-8></script></body></html>