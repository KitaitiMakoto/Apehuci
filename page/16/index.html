<!DOCTYPE html><html><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta charset=utf-8><meta name=description content="北市真の日記"><meta content="width=device-width,initial-scale=1.0" name=viewport><title>アペフチ</title><script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script><link href="../../components/elements.vulcanized.html" rel=import /><link rel=alternate type="application/atom+xml" title="アペフチ" href="../../recent-days.atom"/><link href="../../bower_components/sanitize-css/sanitize.css" rel=stylesheet /><link href="../../stylesheets/highlight-81ca03d6.css" rel=stylesheet /><script src="../../javascripts/all-d7c52391.js"></script><link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="../../images/favicon-8d71db77.png" rel=icon type="image/png" size=60x60 /><link href="/apehuci/manifest.json" rel=manifest><meta name=theme-color content="#b71c1c"><meta name=og:description content="北市真の日記"><meta name=og:title content="アペフチ"><meta name=twitter:card content=summary><meta name=twitter:site content=@KitaitiMakoto><meta name=twitter:image content="https://kitaitimakoto.github.io/apehuci/images/icon-bbe8ac52.png"><meta name=robots content="noindex,follow"></head><body class="page page_16 page_16_index"><blog-router base-regex="^/apehuci/"></blog-router><main><app-header-layout><app-header fixed condenses effects=waterfall slot=header><app-toolbar></app-toolbar><app-toolbar sticky><h1 class=site-title><a href="../../">アペフチ</a></h1></app-toolbar></app-header><article><paper-card elevation=2><a href="../../2015/12/05.html"><h1>DroongaをインストールするItamaeレシピ</h1><time pubdate>2015-12-05</time></a><ul class=tags><li><a href="../../tags/droonga.html" rel=tag>Droonga</a></li><li><a href="../../tags/itamae.html" rel=tag>Itamae</a></li></ul><p>今日の日記は<a href="http://qiita.com/advent-calendar/2015/groonga">Groonga Advent Calendar 2015</a>の五日目です。昨日は<a href="http://qiita.com/cosmo0920">cosmo0920</a>さんの<a href="http://qiita.com/cosmo0920/items/ed7e071d111c533e217c">Groonga族のHomebrewの変遷を振り返る</a>でした。やっぱりコマンド一つで簡単にインストールできるのはよい。しかし、そのためには陰で誰かが苦労しているということも伺える記事だった。</p><p>今日は、Homebrewなどで一発インストールのできないGroonga族の一員、<a href="http://droonga.org/ja/">Droonga</a>のインストールについて書く。</p><p>Groongaにはレプリケーション機能がない。DroongaはGroongaを複数のマシンにレプリケーションさせるプロダクトだ。公式サイトのほか、<a href="http://qiita.com/advent-calendar/2014/groonga">去年のGroonga Advent Calendar</a>にも記事があって、とても面白く読んだ。Droongaが何かということはこれらを見てほしい。</p><p>公式サイトには勿論<a href="http://droonga.org/ja/install/">インストール手順</a>も書かれているのだが、今日時点でこれはうまくいかない。そこで僕は、サーバーの構成管理ツールである<a href="http://itamae.kitchen/">Itamae</a>のレシピを作ってインストールしている。今日はそれを使ったインストール方法を書こうと思う。以下、<a href="https://www.vagrantup.com/">Vagrant</a>を使ってUbuntu 15.04の環境で実行している。マシンイメージは<a href="https://atlas.hashicorp.com/boxes/search?utm_source=vagrantcloud.com&amp;vagrantcloud=1">Vagrant Cloud</a>から<a href="https://atlas.hashicorp.com/ubuntu/boxes/vivid64">公式のイメージ</a>を持って来た。</p><p>Droongaのインストール時にはメモリーが必要なので、<code class=highlighter-rouge>Vagrantfile</code>に設定を書いて2GiBくらい確保しておく。</p><div class="language-ruby highlighter-rouge"><pre class=highlight><code><span class="no">Vagrant</span><span class="p">.</span><span class="nf">configure</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">define</span> <span class="ss">:ubuntu1504</span> <span class="k">do</span> <span class="o">|</span><span class="n">node</span><span class="o">|</span>
    <span class="n">node</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">box</span> <span class="o">=</span> <span class="s2">"ubuntu/vivid64"</span>
    <span class="n">node</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">provider</span> <span class="s2">"virtualbox"</span> <span class="k">do</span> <span class="o">|</span><span class="n">provider</span><span class="o">|</span>
      <span class="n">provider</span><span class="p">.</span><span class="nf">memory</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="c1"># :</span>
  <span class="c1"># :</span>
<span class="k">end</span>
</code></pre></div><p>バーチャルマシンを起動したら、まずログインして環境を更新する。</p><div class=highlighter-rouge><pre class=highlight><code>[host]$ vagrant up ubuntu1504
[host]$ vagrant ssh ubuntu1504
[vm]$ sudo apt-get update
[vm]$ sudo apt-get upgrade -y
</code></pre></div><p>ここでようやくレシピの登場。GitHubに上げている（<a href="https://github.com/KitaitiMakoto/itamae-plugin-recipe-droonga">https://github.com/KitaitiMakoto/itamae-plugin-recipe-droonga</a>）。gemまたはItamaeプラグインの形をしているがrubygems.orgには上げていないので、<code class=highlighter-rouge>git clone</code>で持って来る必要がある。もっと一般的にしてからリリースしたいなと思って、そのまま時間が過ぎてしまっているのだ……。</p><div class=highlighter-rouge><pre class=highlight><code>[host]$ git clone https://github.com/KitaitiMakoto/itamae-plugin-recipe-droonga.git
</code></pre></div><p>リポジトリーをクローンしたら、Itamaeのレシピファイル（ここでは<code class=highlighter-rouge>recipe.rb</code>）を用意して、以下のように一行書く。</p><div class="language-ruby highlighter-rouge"><pre class=highlight><code><span class="n">include_recipe</span> <span class="s2">"./itamae-plugin-recipe-droonga
/lib/itamae/plugin/recipe/droonga/default.rb"</span>

</code></pre></div><p>そうしたらItamaeを実行すればよい。簡単だ。但し時間は掛かる。</p><div class=highlighter-rouge><pre class=highlight><code>[host]$ itamae ssh --vagrant --host ubuntu1504 recipe.rb
</code></pre></div><p>（上のイメージだとこれでいいが、DigitalOceanだと依存パッケージが足りなくてうまくいかなかったかも知れない。エラーメッセージを見ながら必要な物をインストールしてほしい。）</p><p>Droongaは二つのコンポーネントからなっている。Groongaデータベースを操作したり、他ノードと連携してレプリケーションを実現する<a href="https://github.com/droonga/droonga-engine">Droonga Engine</a>と、そこへのHTTPインターフェイスを提供する<a href="https://github.com/droonga/droonga-http-server">Droonga HTTP Server</a>だ。それぞれそれ用のプロセスを起動する必要がある。</p><p>公式サイトの記事では<code class=highlighter-rouge>service</code>コマンドを使ってこれをコントロールすることになっているが、Ubuntuでは15.04からUpstartに代わってsystemdが導入されたので、レシピでは<code class=highlighter-rouge>systemctl</code>コマンドを使うようにしている。</p><div class=highlighter-rouge><pre class=highlight><code>[vm]$ sudo systemctl status droong-engine
● droonga-engine.service - Droonga Engine
Loaded: loaded (/lib/systemd/system/droonga-engine.service; enabled; vendor preset: enabled)
Active: active (running) since Fri 2015-12-04 20:09:56 UTC; 37s ago
Main PID: 30190 (droonga-engine)
CGroup: /system.slice/droonga-engine.service
(snip)
[vm]$ sudo systemctl status droonga-http-server
● droonga-http-server.service - Droonga HTTP Server
Loaded: loaded (/lib/systemd/system/droonga-http-server.service; enabled; vendor preset: enabled)
Active: active (running) since Fri 2015-12-04 20:09:57 UTC; 2min 11s ago
Main PID: 30228 (node)
CGroup: /system.slice/droonga-http-server.service
(snip)
</code></pre></div><p>これでDroongaが動くはずだし、実際<a href="http://epub-searcher-demo.kitaitimakoto.net/">EPUB Searcherデモサイト</a>ではこの方法でインストールして、現在でも動作している。</p><p>尚、Droongaを動かすには、内部・外部から、<code class=highlighter-rouge>hostname</code>で返って来るホスト名で名前解決できる必要がある。<code class=highlighter-rouge>hostname</code>と違うホスト名を使いたい場合は、レシピのインストールの箇所（<a href="https://github.com/KitaitiMakoto/itamae-plugin-recipe-droonga/blob/87c7c9015b626a84b14bfa226d399eb02839bd84/lib/itamae/plugin/recipe/droonga/default.rb#L28">Droonga Engine該当箇所</a>、<a href="https://github.com/KitaitiMakoto/itamae-plugin-recipe-droonga/blob/87c7c9015b626a84b14bfa226d399eb02839bd84/lib/itamae/plugin/recipe/droonga/default.rb#L36">Droonga HTTP Server該当箇所</a>）の最後の<code class=highlighter-rouge>bash</code>実行時に<code class=highlighter-rouge>HOST</code>環境を設定し、また<code class=highlighter-rouge>/etc/hosts</code>でも設定する必要があるので書き換えること。</p><div class="language-ruby highlighter-rouge"><pre class=highlight><code><span class="c1"># :</span>
<span class="c1"># :</span>
<span class="n">execute</span> <span class="s2">"curl -sL https://deb.nodesource.com/setup_0.12 | bash HOST=..."</span> <span class="k">do</span>
  <span class="n">not_if</span> <span class="s2">"test -e /etc/apt/sources.list.d/nodesource.list"</span>
<span class="k">end</span>
<span class="c1"># :</span>
<span class="c1"># :</span>
<span class="n">execute</span> <span class="s2">"curl https://raw.githubusercontent.com/droonga/droonga-engine/master/install.sh | bash HOST=..."</span> <span class="k">do</span>
  <span class="n">not_if</span> <span class="s2">"type droonga-engine"</span>
<span class="k">end</span>
<span class="c1"># :</span>
<span class="c1"># :</span>
</code></pre></div></paper-card></article><article><paper-card elevation=2><a href="../../2015/12/03.html"><h1>Firefox for AndroidでもPolymerが動作するようにする</h1><time pubdate>2015-12-03</time></a><ul class=tags><li><a href="../../tags/web.html" rel=tag>Webコンポーネント</a></li><li><a href="../../tags/polymer.html" rel=tag>Polymer</a></li></ul><p>この日記は<a href="https://www.polymer-project.org/">Polymer</a> 1.2.1で作っているのだが、この前まで僕のメインブラウザーであるFirefox for Androidでは読めなかった。今でも<a href="https://elements.polymer-project.org/">Polymer Element Catalog</a>のサイトを見るとそれが体験できる。Firefox for PCでは問題ない。Firefox for iOSは知らない。</p><p><a href="http://webcomponents.org/polyfills/">webcomponentsjs</a>やPolymerに<code class=highlighter-rouge>console.log()</code>を仕込みながらプリントデバッグを頑張って原因を突き止めたところ、webcomponentsjsでの<a href="http://www.w3.org/TR/html-imports/">HTMLインポート</a>の検出に問題があることが分かった。現時点でのwebcomponentsjsでは、ブラウザーにHTMLインポートの機能があるかどうかを、<code class=highlighter-rouge>link</code>要素の（JavaScriptの）オブジェクトに<code class=highlighter-rouge>import</code>プロパティ（あれば関数）が存在するかどうか、<code class=highlighter-rouge>in</code>演算子で確認してチェックして判断している（<a href="https://github.com/webcomponents/webcomponentsjs/blob/fedfe0210aa853a9531bd976f6d161d585cc22fb/src/HTMLImports/base.js#L28">該当箇所</a>）。HTMLインポートをサポートしていないブラウザー（Firefox for PCなど）では<code class=highlighter-rouge>import</code>プロパティが存在せず、その場合はshimを使う。ところがFirefox for Androidでは、「<code class=highlighter-rouge>link</code>要素に<code class=highlighter-rouge>import</code>プロパティが存在する」「しかしHTMLインポート機能はサポートしていない」ということになっている。<code class=highlighter-rouge>link.import</code>が、<code class=highlighter-rouge>null</code>になっているのだ。たとえ<code class=highlighter-rouge>null</code>であっても、値が存在すれば<code class=highlighter-rouge>in</code>演算子は<code class=highlighter-rouge>true</code>を返す。従ってFirefox for AndroidにはHTMLインポート機能が存在する、とwebcomponentsjsは判断しているわけだ。</p><p>一応、<a href="https://github.com/webcomponents/webcomponentsjs/issues/452">バグレポート</a>はした。プルリクエストはリクエストしなかった。<a href="https://github.com/webcomponents/webcomponentsjs/blob/master/CONTRIBUTING.md">コントリビューションページ</a>によると、コントリビュートするにはライセンスに同意する必要がある。それは構わなかったのだが、同意手続きの過程で住所を入力欄が現れた。それも必須項目として。漠然と不安を覚えてプルリクエストは躊躇ってしまった。</p><p>webcomponentsjsでこの問題が対応されるかは分からない。だから今この日記ではこんなワークアラウンドを入れている。</p><div class="language-javascript highlighter-rouge"><pre class=highlight><code><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">ua</span> <span class="o">=</span> <span class="nx">navigator</span><span class="p">.</span><span class="nx">userAgent</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">ua</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s2">"Android"</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
    <span class="nx">ua</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s2">"Firefox"</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">"link"</span><span class="p">).</span><span class="kr">import</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="nx">HTMLLinkElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kr">import</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">})();</span>
</code></pre></div><p>これを、webcomponentsjsをロードする<code class=highlighter-rouge>script</code>タグの<strong>前</strong>に置いている。<code class=highlighter-rouge>if</code>節の条件は<code class=highlighter-rouge>null</code>のチェックだけでよさそうだが、そうするとなぜかChromiumやChromeでページが読めなくなってしまったので、プラットフォームも判断している。なぜ読めなくなったかは調べていない。</p></paper-card></article><article><paper-card elevation=2><a href="../../2015/11/30.html"><h1>Action Cableが便利そう</h1><time pubdate>2015-11-30</time></a><ul class=tags><li><a href="../../tags/action-cable.html" rel=tag>Action Cable</a></li><li><a href="../../tags/ruby.html" rel=tag>Ruby</a></li><li><a href="../../tags/ruby-on-rails.html" rel=tag>Ruby on Rails</a></li></ul><p>とても久し振りに<a href="https://sendagayarb.doorkeeper.jp/">Sendagaya.rb</a>に参加して来た。</p><p><a href="https://sendagayarb.doorkeeper.jp/events/35276">第128回</a>の今日は、三十分くらい雑談した後、QiitaのAction Cableの記事<a href="http://qiita.com/bisque33/items/1360477c2260b361ec03">[Rails5]Action Cableのサンプルを読み解いてみる</a>を読みながらああだこうだ言っていた。一通り見ての感想は「便利そう」「使いたい」。</p><p><a href="https://github.com/rails/actioncable">Action Cable</a>はRails 5から入るらしい新機能で、WebSocketをRailsに統合した形で扱える物らしい。まともに記事など読んだのは今日が初めてで、これがRais界隈でどれくらい認知されているかは分からない。僕が「RailsでWebSocket」と聞いて漠然と思い浮かべたのが<code class=highlighter-rouge>ActionController::Live</code>だったのだけど全然違う（<code class=highlighter-rouge>ActionController::Live</code>については<a href="http://tenderlovemaking.com/2012/07/30/is-it-live.html">Is It Live?</a>がよい紹介記事だ）。</p><p>Action Cableでは、Railsのプロセスの他にAction Cable用のプロセスを立ち上げる。こいつがブラウザーとWebSocketで通信する。普通だ。Action Cableのいい所はここからで、Railsとセッション用のクッキー情報を共有できる（電子署名が付いているあれだ）。だから、WebSocketを使ってAction Cableに接続してきたクライアントが、Rails（のデータベース）で管理しているどのユーザーに相当するのか、見付けることができるのだ。</p><p>更に、Railsのプロセスからブラウザーに、WebSocket経由でメッセージを送ることができる。例えば、フォームなどから普通にコメントを投稿した時に、そのことをWebSocketで繋がっている全ユーザーに通知できる。だがRailsがWebSocketを使ってAction Cableに接続しているわけではない。Active Jobを使ってRedisにメッセージを送信するのだ。Action CableはRedisのpubsub機能を使っていて、Rails（Active Job実装のワーカープロセス）がパブリッシャー、Action Cableプロセスがサブスクライバーになっている。Action Cableはサブスクライブしたメッセージを、予めAction Cable用に書かれたコードに従って、必要なクライアントに流す。もちろん、クライアント同士WebSocket経由での通信もできる。（そう言えば、はて、クライアントからDBのレコードを弄るような場合、Action Cableプロセスがやるのだろうか、Railsプロセスがやるのだろうか。後者はフォームなりAjaxなりでやることが自然に思い浮かべられるが、前者は逆方向のpubsubになる？　と考えると、そういうことはなさそうだなと思う。）</p><div class=highlighter-rouge><pre class=highlight><code>Rails --(Active Job)--&gt; Worker --(Redis pubsub)--&gt; Cable --(WebSocket)--&gt; Clients
</code></pre></div><p>副産物として、始めからRedisのpubsubでWebSocketサーバーをつなぐのが前提なので、プロセスを増やすだけで簡単にスケールアウトさせられそうだ。これは悪いことではない、というかむしろいいことだが、Railsはモノリシックなのが特徴の一つという印象を持っていたので、結構変わり種のコンポーネントだな、と感じた。繰り返すが悪いことではない。</p><p>と、便利なところだったが、実は半分くらいは推測で書いている。件の記事の内容からは内部の動きは分からないからだ。だから今度はAction Cableのソースコードを読みたいと思っているし、もしかしたら次回のSendagaya.rbでソースコードリーディングができるかも知れない。</p><p>余談。「RailsからRedisにパブリッシュするためにはSidekiqなどが必要で、更に別のプロセスを立てないといけない」といった話をしている時に、<a href="https://twitter.com/tkawa">@tkawa</a>さんに<a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a>を教えてもらった。Railsプロセス内にCelluloidを使ってアクタースレッドを立て、それを使ってActive Jobのジョブを実行する物のようだ。ぱっと見本番で使っていいかは不安に思ったが、開発環境で使う分には便利だろう。</p></paper-card></article><footer><ul><li class=next><a href="../15/" rel=next><paper-button raised>前3日分</paper-button></a></li><li class=prev><a href="../17/" rel=prev><paper-button raised>次3日分</paper-button></a></li></ul><paper-card><blog-search url="https://search.apehuci.kitaitimakoto.net/d" base=/apehuci/ table=Apehuci debounce-duration=300></blog-search></paper-card><paper-card> &copy; <a class=copy href="https://twitter.com/KitaitiMakoto">北市真</a></paper-card></footer></app-header-layout></main><script async="" src="//platform.twitter.com/widgets.js" charset=utf-8></script></body></html>