<!DOCTYPE html><html><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta charset=utf-8><meta name=description content="北市真の日記"><meta content="width=device-width,initial-scale=1.0" name=viewport><title>アペフチ</title><script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script><link href="../../components/elements.vulcanized.html" rel=import /><link rel=alternate type="application/atom+xml" title="アペフチ" href="../../recent-days.atom"/><link href="../../bower_components/sanitize-css/sanitize.css" rel=stylesheet /><link href="../../stylesheets/highlight-81ca03d6.css" rel=stylesheet /><script src="../../javascripts/all-d7c52391.js"></script><link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="../../images/favicon-8d71db77.png" rel=icon type="image/png" size=60x60 /><link href="/apehuci/manifest.json" rel=manifest><meta name=theme-color content="#b71c1c"><meta name=og:description content="北市真の日記"><meta name=og:title content="アペフチ"><meta name=twitter:card content=summary><meta name=twitter:site content=@KitaitiMakoto><meta name=twitter:image content="https://kitaitimakoto.github.io/apehuci/images/icon-bbe8ac52.png"><meta name=robots content="noindex,follow"></head><body class="page page_10 page_10_index"><blog-router base-regex="^/apehuci/"></blog-router><main><app-header-layout><app-header fixed condenses effects=waterfall slot=header><app-toolbar></app-toolbar><app-toolbar sticky><h1 class=site-title><a href="../../">アペフチ</a></h1></app-toolbar></app-header><article><paper-card elevation=2><a href="../../2016/02/15.html"><h1>Sendagaya.rb #137</h1><time pubdate>2016-02-15</time></a><ul class=tags><li><a href="../../tags/ruby.html" rel=tag>Ruby</a></li><li><a href="../../tags/ruby-on-rails.html" rel=tag>Ruby on Rails</a></li></ul><p><a href="https://sendagayarb.doorkeeper.jp/events/39087">Sendagaya.rb #137</a>に参加して来た。『メタプログラミングRuby 第2版』と、Active Record enumsの話をして来た。</p><h2 id=ruby-3->メタプログラミングRuby 3章 メソッド</h2><p>今回も<a href="https://www.oreilly.co.jp/books/9784873117430/">メタプログラミングRuby</a>を読んだ。「3章 メソッド」から（こういう時、章にもリンクを貼りたいものだ）。</p><p>同じようなメソッドの定義を繰り返すのではなく、動的に定義することで、重複した記述を減らす方法が紹介される。</p><div class="language-ruby highlighter-rouge"><pre class=highlight><code><span class="k">class</span> <span class="nc">Computer</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">computer_id</span><span class="p">,</span> <span class="n">data_source</span><span class="p">)</span>
    <span class="vi">@id</span> <span class="o">=</span> <span class="n">computer_id</span>
    <span class="vi">@data_source</span> <span class="o">=</span> <span class="n">data_source</span>
  <span class="k">end</span>

   <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_component</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="n">define_method</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">info</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">send</span> <span class="s2">"get_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_info"</span><span class="p">,</span> <span class="vi">@id</span>
      <span class="n">price</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">send</span> <span class="s2">"get_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_price"</span><span class="p">,</span> <span class="vi">@id</span>
      <span class="n">result</span> <span class="o">=</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">capitalize</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">info</span><span class="si">}</span><span class="s2"> ($</span><span class="si">#{</span><span class="n">price</span><span class="si">}</span><span class="s2">)"</span>
      <span class="k">return</span> <span class="s2">"* </span><span class="si">#{</span><span class="n">result</span><span class="si">}</span><span class="s2">"</span> <span class="k">if</span> <span class="n">price</span> <span class="o">&gt;=</span> <span class="mi">100</span>
      <span class="n">result</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">define_component</span> <span class="ss">:mouse</span>
  <span class="n">define_component</span> <span class="ss">:cpu</span>
  <span class="n">define_component</span> <span class="ss">:keyboard</span>
<span class="k">end</span>
</code></pre></div><p>これで</p><div class="language-ruby highlighter-rouge"><pre class=highlight><code>  <span class="k">def</span> <span class="nf">mouse</span>
    <span class="n">info</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">get_mouse_info</span><span class="p">(</span><span class="vi">@id</span><span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="vi">@data_source</span><span class="p">.</span><span class="nf">get_mouse_price</span><span class="p">(</span><span class="vi">@id</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s2">"Mouse: </span><span class="si">#{</span><span class="n">info</span><span class="si">}</span><span class="s2"> ($</span><span class="si">#{</span><span class="n">price</span><span class="si">}</span><span class="s2">)"</span>
    <span class="k">return</span> <span class="s2">"* </span><span class="si">#{</span><span class="n">result</span><span class="si">}</span><span class="s2">"</span> <span class="k">if</span> <span class="n">price</span> <span class="o">&gt;=</span> <span class="mi">100</span>
    <span class="n">result</span>
  <span class="k">end</span>
</code></pre></div><p>みたいなメソッドを幾つも書く作業から開放される。例によってふんふんなるほどと読んでいたが、例によって甘かった。十五分読んだ後にみんなで話している時に、このコードの「危なさ」を指摘する声が上がった。</p><p>「<code class=highlighter-rouge>initialize</code>で<code class=highlighter-rouge>data_source</code>を引数に受け取っているが、別々のインスタンス初期化時に別々の<code class=highlighter-rouge>data_source</code>を受け取り得るから、クラス全体が和集合のような不要なメソッドも持った物になる」とのことだった。僕にはぴんとこなかった。その後、コードを使って説明してくれた。</p><div class="language-ruby highlighter-rouge"><pre class=highlight><code><span class="nb">methods</span> <span class="o">=</span> <span class="p">[</span><span class="ss">:moge</span><span class="p">,</span> <span class="ss">:hoge</span><span class="p">]</span>
<span class="n">methods2</span> <span class="o">=</span> <span class="p">[</span><span class="ss">:moge</span><span class="p">,</span> <span class="ss">:hoge</span><span class="p">,</span> <span class="ss">:age</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Computer</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">methods</span><span class="p">)</span>
    <span class="nb">methods</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">method</span><span class="o">|</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">define_kick</span> <span class="nb">method</span>
      <span class="nb">puts</span> <span class="nb">method</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_kick</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="n">define_method</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_kick"</span><span class="p">)</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="s1">'name'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="n">c1</span> <span class="o">=</span> <span class="no">Computer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">methods</span><span class="p">)</span>         <span class="c1"># =&gt; "moge"、"hoge"を出力</span>
<span class="nb">p</span> <span class="n">c1</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="c1"># =&gt; [:moge_kick, :hoge_kick]</span>
<span class="n">c2</span> <span class="o">=</span> <span class="no">Computer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">methods2</span><span class="p">)</span>        <span class="c1"># =&gt; "moge"、"hoge"、"age"を出力</span>
<span class="nb">p</span> <span class="n">c2</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="c1"># =&gt; [:moge_kick, :hoge_kick, :age_kick]</span>
<span class="nb">p</span> <span class="n">c1</span><span class="p">.</span><span class="nf">class</span> <span class="o">==</span> <span class="n">c2</span><span class="p">.</span><span class="nf">class</span>             <span class="c1"># =&gt; true</span>
<span class="nb">p</span> <span class="n">c1</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="c1"># =&gt; [:moge_kick, :hoge_kick, :age_kick]</span>
</code></pre></div><p>（少しコメントを足し、改変した）</p><p>最後の行、<code class=highlighter-rouge>c1</code>でも期待しないメソッド<code class=highlighter-rouge>#age_kick</code>が使えることを示している（その前の行からも明らかだが）。こういう危なさがあることに、僕は気が付かなかった。勿論、これが「危ない」かどうかは作るアプリケーション次第だ。別にこれで構わないということも理論上ある。それは何かと話していて、「サンプル」かなとなった。</p><h2 id=activerecord-enumsdb>ActiveRecord enumsのDB内での値を文字列にする</h2><p>その後、今日は何を話そうかと話していると、Rails 4.1から入った<a href="http://edgeguides.rubyonrails.org/4_1_release_notes.html#active-record-enums">ActiveRecord enums</a>の機能についての相談が上がった。</p><p>この機能はRDBMSなんかでも実装されているenum（列挙型）の機能をRailsのレイヤーで実装した物で、ユーザー（Railsを使うプログラマー）はモデルオブジェクトが提供する、人間が読みやすいインターフェイスだけ扱っていればいいようになる。バックエンドではActiveRecordが数値に変換してDBに格納し、ユーザーとの間を取り持ってくれる。</p><p>今回の相談は、この機能ではDBに格納する値も文字列にすることができるが、それは普通ではないのだろうか？　という物。</p><p>始め、「何となく気持ち悪いですね」くらいしか言うことができなかった。一応、データサイズが増えるというのもあるが、このご時世、そこは気にするポイントではないだろうとのこと。しばらく話しながら思い付いたのは、文字列にするとインデックスを張ることになるだろうから、インサート時にインデックスを更新するコストが掛かって（遅くなって）しまうということだった。これはそれなりに妥当だと受け取られて、「じゃあ、やっぱり（ActiveRecordの）enumのバックエンドは数値にしておくのが普通なんですね」ということになった。</p><p>ちなみに相談者が文字列を使いたい一番の背景は、Railsは分からないがSQLなら分かるという人のいる場（に、今いるらしい）では、値が数値で返って来ると人間の方で対応する文字列を参照しないといけないので、嫌だ、ということだった。これは勿論妥当だと思うので、この人のケースでは、文字列を使うのは正解だと思う（が、<a href="https://github.com/sferik/rails_admin">RailsAdmin</a>がエラーになるという問題があるらしかった）。それは置いておいても割と一般的に文字列を使いたいこだわりがありそうだったが、そこは深く話さなかった。今思うともったいなかったかも知れない。</p><p>「そう言えば、Railsを使うとマスターテーブルを作ることをしなくなるな」という話もした。『<a href="https://www.oreilly.co.jp/books/9784873114163/">エンタープライズRails</a>』には「アプリケーションのフレームワークや言語よりも、データベースのデータのほうが長く残るから、データだけで完結できるようにしておくべきだ」と書いてあったように思うのだけど、時代も違うし、エンタープライズだとウェブのコンシューマー向けサービスとは領域も違うということだろうか。</p></paper-card></article><article><paper-card elevation=2><a href="../../2016/02/12.html"><h1>実例を元にした全文検索エンジン（Groonga）のテーブル設計</h1><time pubdate>2016-02-12</time></a><ul class=tags><li><a href="../../tags/.html" rel=tag>全文検索</a></li><li><a href="../../tags/groonga.html" rel=tag>Groonga</a></li></ul><p><a href="https://groonga.doorkeeper.jp/events/38529">Groongaで学ぶ全文検索 2016-02-12</a>に行って来た。今日は、参加者が勉強にと国立国会図書館の書誌情報データを取って来てGroongaに入れてみている、だが今のテーブル設計がいいのか分からないということだったので、それをまず説明してもらって、<a href="https://twitter.com/ktou">@ktou</a>さんが各テーブル作成時のオプションなどを説明してくれた。</p><p>インデックスを作る前と後で検索結果を比較していて、インデックス作ってそっちで検索すると20倍速くなったということで、インデックスの有用性が証明されてた。</p><p>そんなわけで個別に色々説明してくれたのだが、まとまっているわけではないので、幾つか取り上げることにする。</p><h2 id=withposition>WITH_POSITIONの活躍</h2><p>今回はインデックステーブルを作る時に、タイトルに対応するインデックスカラムを作る時に<code class=highlighter-rouge>COLUMN_INDEX|WITH_POSITION</code>と、<code class=highlighter-rouge>WITH_POSITION</code>が指定されていた。これがうまく活きる状況の話があった。</p><p>『一、二年生の基礎英作文』というタイトルの本があった。これに対して「一年生」で検索した時に、この本はヒットするだろうか。但し、実際のトークナイザーは<code class=highlighter-rouge>TokenBigram</code>が選ばれていたが、仮に<code class=highlighter-rouge>TokenMecab</code>にしたとする。</p><p>タイトルは「一」「、」「二」「年生」「の」……とMeCabはトークナイズした。検索クエリーは「一」「年生」になる。とすると、このタイトルはクエリーのトークン「一」にも「年生」にもヒットするので、ヒットしそうだ。しかししない。なぜならGroongaはこのタイトルカラムではキーワードの位置情報も持っていて、「一」と「年生」がこの順番で隣り合っていないことを知っているからだ。同様の理由で、仮に『二年生の基礎英作文（一）』みたいなタイトルの本があったとしてもヒットしない。このように、「キーワードが文書中でどの位置にあるか」という情報も持たせるオプションが<code class=highlighter-rouge>WITH_POSITION</code>。なので逆に、これを指定していなければ上のクエリーでこの文書はヒットするだろう。</p><p>MeCabみたいな形態素解析をせずbi-gramで<code class=highlighter-rouge>WITH_POSITION</code>なし、みたいなカラムを作ると、色々な物がヒットし過ぎて検索には使い物にならないカラムになったりもする。</p><h2 id=bi-gram>bi-gramでトークナイズしている時は、一文字では検索できないのか？</h2><p>bi-gramでトークナイズしている時は、インデックスのキーには二文字の文字列が入っている（文末など場合によっては一文字もある）。そういう時に、検索クエリーが一文字の時には、何もヒットしなくなるのでは？　という疑問が出た。</p><p>答えはヒットする。今回の実例では、インデックスキーをパトリシリアトライで作っていた（＝ハッシュにしていなかった）から。パトリシアトライなら前方一致検索ができるので、一文字のクエリーでも探すことができる。なぜパトリシアトライなら前方一致検索ができるのか？　忘れた。もうパトリシアトライの構造を忘れたので後で見ておく……。</p><p>尚、MySQL 5.7から入ったInnoDBの全文検索機能では、bi-gramでトークナイズする設定にすると、実際に一文字での検索ではヒットしなくなるらしい。</p><h2 id=section>テーブルのキーに選ぶべき物</h2><p>今回は、国会図書館から提供されているTSVのうち、URL、タイトル、著者、出版社をGroongaに入れていた。テーブルとしてはハッシュテーブルを選び、キーにURIを入れていた。これは正しい設計だろうか？</p><p>具体的なアプリケーションの要件によって、考慮するべきことがある。</p><ul><li>ハッシュテーブルでいいだろうか？</li><li>いいとして、キーはURLでいいだろうか？</li></ul><p>ハッシュテーブルのいい所は、キーが存在していて、そのキーを使ってレコードを一意に特定できる所。逆に言うと特定する必要がない、つまり後からレコードを探して更新や削除をすることが無いのであれば、ハッシュテーブルを使う必要はない。追加しか無いのなら、配列を使ってもいい。</p><p>ハッシュテーブルを選んだとして、そのキーカラムのサイズは（現在のGroongaでは）4KiBになっている。普通それならURLを入れても大丈夫だろうと思うが、溢れることがあると@ktouさんは主張していた（何か嫌な思い出がありそうだった）。ので、今回の場合だと、選択したカラムにはなかったが、ISBNを使うのがよさそうとのこと。また、そういう一意かつ短めの物が選べない時は、一意な物のハッシュ値を計算してキーとして入れるといいとのこと。</p></paper-card></article><article><paper-card elevation=2><a href="../../2016/02/07.html"><h1>日記に検索機能をつけた</h1><time pubdate>2016-02-07</time></a><ul class=tags><li><a href="../../tags/groonga.html" rel=tag>Groonga</a></li><li><a href="../../tags/polymer.html" rel=tag>Polymer</a></li><li><a href="../../tags/middleman.html" rel=tag>Middleman</a></li></ul><p>この日記に検索機能を付けてフッターに置いた。軽快にインクリメンタルサーチができていて、なかなかいい。</p><h2 id=groonga>Groongaを使った全文検索</h2><p>この際に、二つやったことのない作業があって、その一つは検索エンジンを使った検索機能の作成。正直、静的サイトの検索なんて<a href="https://developers.google.com/custom-search/">Google Custom Search</a>や<a href="https://swiftype.com/">Swiftype</a>を使えばいいと思うが、自分で遊ぶための場所を持つというのも日記を移行した目的の一つだったから、自分でやってみた。</p><p><a href="https://middlemanapp.com/jp/">Middleman</a>でサイトをビルドした後、<a href="http://docs.ruby-lang.org/ja/2.3.0/library/rake.html">Rake</a>タスクでビルド済みディレクトリーから日記本文を抽出して、<a href="http://groonga.org/ja/">Groonga</a>に投げ込んでインデックスを作っている。始め、Middlemanのビルド時のidentical、updated、created、removedという状態変化の情報を利用して、必要な分だけGroonga上のインデックスを更新しようかと思っていた（そのための調査結果はQiitaの<a href="http://qiita.com/KitaitiMakoto/items/ca3792f75270b533d37c">Middlemanで「変更なし」「作成」「削除」「変更」の状態を取る</a>という記事に書いた）。でも、実用上それで問題ないのだが、一応「ビルド環境が変わったらそういった状態変化の情報は変わる、ポータブルではない」ということに配慮して、毎回全日記の分をGroongaに投げるようにしている。今のところ、パフォーマンスが問題になったりということは全然ない。</p><p>そのように毎回全部作り直すことにしたので、ローカルでインデックス構築済み<a href="http://groonga.org/ja/docs/reference/executables/groonga-httpd.html">groonga-httpd</a>の<a href="https://www.docker.com/">Docker</a>イメージを作って、それをデプロイするようにしようかとも思った。実際イメージを作るまではやっていた。が、せっかくGroongaがなるべくOSの機能を引き出すように作られているのに、仮想環境で動かすのはもったいないと思って「普通」にインストールして<a href="http://www.freedesktop.org/wiki/Software/systemd/">systemd</a>で起動して使っている（<a href="https://www.linode.com/">Linode</a>を使っているから、まあ、仮想環境ではあるが）。</p><p>何故か<code class=highlighter-rouge>snippet_html()</code>関数がうまく動いていないので、別途調査が必要だ。</p><p>そう言えば、記事を削除した時の対応もRakeタスクにない。消すことがあったら考えよう。記事データをGroongaを投げる時に削除できるよう自動化するのでなく、PostgreSQLの<code class=highlighter-rouge>VACUUM</code>みたいに、ユーザー側で明示的に実行するのでいいと思う。</p><h2 id=polymer>Polymerコンポーネントの作成</h2><p>もう一つは、検索エリアを作るのに、<a href="https://www.polymer-project.org/1.0/">Polymer</a>を使って検索用のコンポーネントを作った（HTMLソースを見れば<code class=highlighter-rouge>&lt;blog-search&gt;</code>というタグが見付かるはずだ）こと。</p><p>作り始め、全く何も表示できず、Polymerに慣れてもいないので自分が何か間違っているかと色々試しすごい時間を費したが、内部で使っているコンポーネントを読み込む<code class=highlighter-rouge>&lt;link&gt;</code>要素の<code class=highlighter-rouge>import</code>属性を<code class=highlighter-rouge>ipmort</code>と書き間違えていただけだった。分かった時には脱力した。</p><p>ユーザー入力（<code class=highlighter-rouge>&lt;paper-input&gt;</code>）、Groongaとの通信（<code class=highlighter-rouge>&lt;iron-ajax&gt;</code>）、その二つの繋ぎ（<code class=highlighter-rouge>&lt;blog-search&gt;</code>）という構成で作ったが、<code class=highlighter-rouge>&lt;blog-search&gt;</code>は昔ながらのjQueryを使った素朴な同期処理のようになってしまった。Polymerにはデータバインディングの仕組みがあるのにもったいない。もう少しすっきりするよう書き換えたい。</p><p>しかし、他のコンポーネント指向のライブラリーもそうだと思うが、閉じたスコープのことだけを考えてHTML、CSS、JavaScriptを書けばよいというのは大分ストレスフリーだ。</p><hr/><p>前からずっと、「あの記事はどこだっけ」と思った時に<code class=highlighter-rouge>git grep</code>してURIを調べてからページを表示していたので、それが無くなって自分が嬉しい機能だ。</p><h2 id=section>追記</h2><p>と思いきや、このサイトは外にリンクを置く時はHTTPSで置いているのだけどgroonga-httpdのdebパッケージにはTLSモジュールが組み込まれていなかった。取り敢えずNginxを前に立てたけど、groonga-httpdのウェブサーバー機能もNginxなので、こちらのビルド時にTLSモジュールを組み込むのが正しいと思う。後でメーリングリストに送って入れてもらうか自分でビルドするかしよう。</p></paper-card></article><footer><ul><li class=next><a href="../9/" rel=next><paper-button raised>前3日分</paper-button></a></li><li class=prev><a href="../11/" rel=prev><paper-button raised>次3日分</paper-button></a></li></ul><paper-card><blog-search url="https://search.apehuci.kitaitimakoto.net/d" base=/apehuci/ table=Apehuci debounce-duration=300></blog-search></paper-card><paper-card> &copy; <a class=copy href="https://twitter.com/KitaitiMakoto">北市真</a></paper-card></footer></app-header-layout></main><script async="" src="//platform.twitter.com/widgets.js" charset=utf-8></script></body></html>