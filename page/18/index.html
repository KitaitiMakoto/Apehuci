<!DOCTYPE html><html><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta charset=utf-8><meta name=description content="北市真の日記"><meta content="width=device-width,initial-scale=1.0" name=viewport><title>アペフチ</title><script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script><link href="../../components/elements.vulcanized.html" rel=import /><link rel=alternate type="application/atom+xml" title="アペフチ" href="../../recent-days.atom"/><link href="../../bower_components/sanitize-css/sanitize.css" rel=stylesheet /><link href="../../stylesheets/highlight-81ca03d6.css" rel=stylesheet /><script src="../../javascripts/all-d7c52391.js"></script><link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="../../images/favicon-8d71db77.png" rel=icon type="image/png" size=60x60 /><link href="/apehuci/manifest.json" rel=manifest><meta name=theme-color content="#b71c1c"><meta name=og:description content="北市真の日記"><meta name=og:title content="アペフチ"><meta name=twitter:card content=summary><meta name=twitter:site content=@KitaitiMakoto><meta name=twitter:image content="https://kitaitimakoto.github.io/apehuci/images/icon-bbe8ac52.png"><meta name=robots content="noindex,follow"></head><body class="page page_18 page_18_index"><blog-router base-regex="^/apehuci/"></blog-router><main><app-header-layout><app-header fixed condenses effects=waterfall slot=header><app-toolbar></app-toolbar><app-toolbar sticky><h1 class=site-title><a href="../../">アペフチ</a></h1></app-toolbar></app-header><article><paper-card elevation=2><a href="../../2015/11/06.html"><h1>全文検索の精度とスコアについて</h1><time pubdate>2015-11-06</time></a><ul class=tags><li><a href="../../tags/.html" rel=tag>全文検索</a></li><li><a href="../../tags/groonga.html" rel=tag>Groonga</a></li></ul><p><a href="https://groonga.doorkeeper.jp/events/33701">Groongaで学ぶ全文検索 2015-11-06</a>に参加してきた。</p><p>今日のお題は「精度」。</p><h2 id=section>精度とは</h2><p>精度とは何か、参加者からはこんな意見が出た。</p><ul><li>ユーザーの満足度</li><li>思った物が探せてる</li><li>もれなく検索できてる</li><li>ごみがない</li></ul><p>ここから<a href="https://twitter.com/ktou">@ktou</a>さんの説明。精度に入る前に、再現率と適合率の説明があった。</p><h3 id=section-1>再現率</h3><p>検索した時に返すべき物があるはず。<br/> 例えば「京都」で検索した時、「京都」を含む文書は全部返って来てほしい（ここではそういうことにする）。ところがトークナイザーに形態素解析器を使っていて、「京都」で検索した時に「東京都」はヒットしないような設定にしていたりすることもある。こういう時、その「東京都」の文書は検索結果から漏れてしまうので、再現率を下げてしまうことになる。<br/> 再現率は、「検索結果で返ってくる<strong>べき</strong>物のうち、実際に検索エンジンが返した物の割合」。</p><h3 id=section-2>適合率</h3><p>上で「返す<strong>べき</strong>物」という話をしたので引き続きそれを使うと、「実際に返って来た検索結果のうち、返すべきだった物の割合」が適合率。<br/> 再現率を上げるためには、例えば登録している文書すべてを検索結果として返すことができる。そうすると「返すべき物」は全て含まれているので、再現率は100%になる。しかし、この結果はいらない物を多量に含んでいるだろうから、期待する結果からは遠い。この時適合率は低いということになる。</p><h3 id=section-3>精度</h3><p>さて、検索エンジンの精度の話をする時、この再現率と適合率が、よく指標として使われる。最初に上げた参加者みんなの精度のイメージのうち「ユーザーの満足度」「思った物が探せてる」はふわっとしてるけど、再現率と適合率は数値化できるので議論しやすい。</p><p>ところが、一般に、どちらかを上げるとどちらかは下がってしまう（らしい）。<br/> 特許検索はふつう、適合率を下げても再現率が重要になる。特許出願を考える際には既存の特許とかぶらないことを確認する必要があるが、その時には、漏れがあっては困るからだ。</p><h3 id=section-4>現実の話</h3><p>再現率と適合率はよく指標として使われるが、現実的には、この二つだけで<del>精度</del><ins>検索結果のよし悪し</ins>を議論できるわけではない。</p><p>例えば検索して、結果が1000件あったとする。この時、ふつう、1000件全部は確認しない。全部を確認しないのであれば、「全体に対しての割合」である再現率や適合率は、その厳密な数値には意味がないことになる。<br/> Googleでヒットした時に大事なのは、多くの場合1ページ目、せいぜい3ページ目くらいまでで、みんなそれを目指してSEOを頑張っていた。なので、4ページ目以降は、不要な検索結果ばかりで適合率が低かったとしても問題ない。</p><p>もちろんこれはGoogle検索はそういう選択をした、またウェブの一般的な検索はそれでいいことが多いだろうということで、ケースバイケースである。</p><h2 id=deldelinsins><del>精度を高める</del><ins>よい検索結果を提示する</ins>には</h2><p><ins>追記。始め「精度を高める」という書き方で書いていた。しかし、他の人のまとめ（前半、講師の<a href="https://twitter.com/ktou">@ktou</a>さんが説明をして、後半で各々自分の言葉でまとめるという勉強会。この日記もそのまとめとして書いている）を聞いているうち、これがよくない表現だと気付いた。精度はやっぱり再現率と適合率のことで、この節で話したいのは「再現率と適合率を考えるだけではユーザによい検索結果を提示することはできない」ということだからだ。</ins></p><p><del>精度を上げる</del><ins>ユーザーによい検索結果を提示する</ins>にはどうすればいいか、方法は一概には言えない。ユースケースごとに求められる精度のタイプが変わるからだ。</p><p>上で見たような「上位n検の結果だけが特に重要」みたいなケースではスコア付けが大事になる。スコア付けには（昔の）GoogleのPageRankや、ほかにTF、TS・IDF、BM25などがある。それぞれが何なのかは省略する。</p><p>確かPageRankは、各ドキュメントの被リンクの数などをスコア付けに使っていたと思う。それが「いい結果」ということでGoogleが受け入れられていった一因になっていた。 <br/> これはTF・IDFなどの、文書中のキーワードから導出した指標の限界を示唆している。<a href="https://twitter.com/ktou">@ktou</a>さんはこのように、キーワードだけを使うのでは、精度はそれほどよくならないと思っているらしい。それよりも文書のメタデータを使ってスコアを考えるほうが現実的にいい結果が得られることが多い。</p><p>メタデータには例えばタグがある。<br/> TF・IDFでは、「文書中のTFが高いつまりある単語が多いという時、その単語はその文書を特徴づけている」と考えている。IDFについては、「ある語がたくさんの文書に含まれているほど、その語は文書の特徴を表現していない」と考える。つまり「その文書の特徴は何なのか」ということが知りたい、その知りたいことの導出に文書中のキーワードを利用していることになる。本質的には文書の特徴が知りたいだけなので、書き手の用意したタグというのは、多くの場合キーワード由来の指標よりも、その特徴を顕著に表していることになるだろう。そうしたわけでタグは、検索結果の重み付けに使う指標として有効と考えられる。</p><p>他に位置情報も考えられる。渋谷を歩いててラーメンを食べたくなった時に、「ラーメン」と検索すると、渋谷のお店を扱った文書が出てきてほしい。仮に文書中に店舗名しかなくて、「渋谷」みたいな場所を示すキーワードがないとする。でも文書のメタデータに渋谷の経緯度があるとすると、それを利用して渋谷の店を検索結果の上位に出すことができる。</p><p>こういった文書のメタデータの他に、検索する人の情報を使うこともできる。今、Googleの検索結果は、（ログインしていれば）訪問した回数の多いページが上位になるようになっている。フェイスブックでの検索も、自分に関連のあるユーザーなんかが結果の上位に来るようになっている。上のラーメンの例でも、スマホからGPSによる位置情報を検索クエリーに乗せて使うことができる。</p><p>こういう風に、<del>精度を高める</del><ins>ユーザーによい検索結果を提示する</ins>には、文書中のキーワードを使うだけでは、限界がありそうだ。</p><h2 id=groonga>Groongaでのスコア付け</h2><p>Groongaでは以下のスコア付けの方法が用意されている</p><ul><li>TF</li><li>TF・IDF</li><li>TFで、リミットありの物。TFは参考情報に使って、メインの重み付けの指標は別にあるといった場合。TFは文書の内容に応じて無限に増えていく（例えばヒットしやすい語を埋め込みまくった記事とか）ので、ある単語を書きまくるというスパムの餌食になりやすい。「その語を含んでいる」という事実は考慮しつつも、その影響を一定範囲に抑えるために、重みのリミットを、例えば2（数値はユーザーが決める）とかにしてしまうやり方。Groongaに特徴的で、<a href="https://twitter.com/ktou">@ktou</a>さんはこの重み付け方法を持っている全文検索エンジンを他に知らないとのこと（ちょっと自身なさそうだったw）。</li><li>メタデータに重みを付けてスコアに反映させるやり方（以下で説明）</li></ul><p>最後のは例えば、居酒屋のテーブルがあったとして、</p><ul><li>居酒屋A … 重みは海鮮：10</li><li>居酒屋B … 海鮮：5</li><li>居酒屋C … 中華：100</li></ul><p>たいなメタデータを入れておく。<br/> グルメサイトで「海鮮が美味しいお店の中から探す」みたいなフィルタリングをしている時は、どんなにその値が高くても、居酒屋Cは上位には出てこないだろう。その重みは海鮮ではなくて中華なのだから。</p><p>と、今日はここまで。</p><p>参加者の一人から「では、他製品と競争するにはメタデータの扱いが重要になるのか」という質問が出ていて、鋭いなあと感心した。</p><p>あと、自分の理解のまとめとしてこの日記を書いている間に、すごい面白そうな話が後ろで繰り広げられていたけど、書くのに忙しくて聞けなかった……。</p><h2 id=tfidfandor>TF・IDFはAND検索、OR検索で使われる</h2><p>追記。<a href="http://flow2flow.hatenablog.jp/entry/2015/11/06/220623">参加者の一人のまとめ</a>発表で、「TF・IDFはAND検索、OR検索で使われる」といった物があった。まとめを書いている時に出た疑問を<a href="https://twitter.com/ktou">@ktou</a>さんに質問して、そのフィードバックを入れたらしい。</p><p>これはぱっと見た時にすぐ意味が頭に入ってこなかったが、分かったらもやもやがすごいすっきりした。</p><p>TFは分かるけどTF・IDFの話が全文検索で出てくるのがぴんとこなくてもやもやしていた。僕がTF・IDFを知ったのは全文検索ではなくて類似文書検索、なので定義やその意味を聞かれれば一応答えられるけど、それが全文検索でどういう意味を持つのか、と聞かれると詰まってしまう（はずだとこの時に気付いた）。</p><p>IDFを考える気持ちは、ある文書とある文書を比べる時に「その二つに共通の特徴でも、そもそも全文書、多数の文書に共通の物は、さほど大事な特徴ではない」ということだ。二つ（以上）の文書を比べる時に出てくる概念なのである。でも全文検索では、ヒットした文書同士を比べるようなことはしないなのにDF・IDFを使っているのでもやもやしていた。</p><p>これがAND検索、OR検索のことを考えると、つまりクエリーが複数あって、それぞれについてヒットする文書群があって、その文書群の文書について何らかのスコア付けをする、ということになる。そう考えるとTF・IDFを使うのは自然に思えた。</p><p>またこういう風にも捉えられる。AND検索にせよOR検索にせよ、クエリーを「複数の単語からなるごく短い文書」だと考えられる。この「ごく短い文書」に似ている文書というのが、すなわち検索結果の文書なのだ。やはり、類似文書検索で使われる手法を使うことは、自然に思える。</p><p>他の人の（ちゃんと疑問を疑問と認識できる）視点で出てきたフィードバックがその場でシェアされるの、ありがたいことである。</p><h2 id=bm25>BM25</h2><p>追記二。（この日記を含む）みんなのまとめの発表が終わった後、解説が省かれていたBM25というスコア付けの方法も説明してもらった。</p><p>BM25はTFとIDFのほかに、文書の長さも考慮する指標。ある単語について「長い文書の中にたくさんあるとして、それはそういうものだろう。短い文書の中にたくさんあるようだと、それはその文書を特徴付けているているキーワードだろう」という考え方で計算する物らしい。<br/> これはある種のスパムブログなんかを弾くことができる。スパムブログで「これ入れとけば検索上位になるっぽい」という単語をひたすら書き連ねているようなやつ、それは文書自体も長くなるので、その分スコアが下がる。</p><p>ただ計算量は増えて、計算量としては「TF &lt; TF・IDF &lt; BM25」という順番になっている。</p></paper-card></article><article><paper-card elevation=2><a href="../../2015/11/04.html"><h1>Polymerでマテリアルデザインする時に読むといい物</h1><time pubdate>2015-11-04</time></a><ul class=tags><li><a href="../../tags/.html" rel=tag>マテリアルデザイン</a></li><li><a href="../../tags/polymer.html" rel=tag>Polymer</a></li></ul><p>Polymer 0.5、0.8の頃は、Polymerでマテリアルデザインするのが（少なくともその取っ掛かりは）簡単だったように思うけど、1.0になって難しくなったと感じていた。0.8でも1.0でも同様に、<a href="https://elements.polymer-project.org/browse?package=paper-elements">Paper Elements</a>というコンポーネントセット（<code class=highlighter-rouge>paper-*</code>というタグ集）が予め用意されていて、それを使うとマテリアルデザインが始められるようになっているのに、どこが違うんだろう。</p><p>というところでググったりしていて思い付いたのは、チュートリアルがないからだ。Polymer 1.0自体のチュートリアルはある（<a href="https://www.polymer-project.org/1.0/docs/start/quick-tour.html">Quick tour of Polymer</a>）。でもこれは、Polymerを使って自分で要素を作り、それを使うというチュートリアルだ。名前もチュートリアルではなくクイックツアーになっている。他に公式サイトで探して見付かるのはPaper Elementsカタログの各要素のサンプルと、あとは<a href="https://developers.google.com/web/tools/polymer-starter-kit/">Polymer Starter Kit</a>くらい。前者はリファレンスなので全体の考え方が掴みにくいし、後者はあっさりしすぎている。</p><p>でもPolymer 0.5は、自分でPaper Elementsを使いながら一つのウェブアプリケーションを作るチュートリアルがあった（<a href="https://www.polymer-project.org/0.5/docs/start/tutorial/intro.html">Getting the starter project</a>）。これをやっていたので0.5でPaper Elementsを使ってページを作るのに、細々したところはともかく、「全体としてはこういう流れてやるんだな」というところに躓いた憶えがなかったのだ（と、いうほど、使っていないけれど）。</p><p>日記をこのGitHub Pages＋Middlemanにするにあたって、フレームワークにPolymerを選んだところで改めて探して、ようやく、Paper Elementsの使い方にふさわしい公式ドキュメントを見付けた。</p><p><a href="https://elements.polymer-project.org/guides/responsive-material-design-layouts">Responsive Material Design layouts</a>だ。</p><p>細かいステップを通じて、レイアウトする時の「枠」を教えてくれる。各ステップでデモンストレーションも用意されているので分かりやすい。おすすめ。</p><p>Polymerの公式サイトを探しているのではだめで、<a href="https://elements.polymer-project.org">Element Catalog</a>の下の方にあるガイドを探すべきだった。上のドキュメントから参照している<a href="https://elements.polymer-project.org/guides/flex-layout">Flexbox layout with iron-flex-layout</a>もほぼ必読のドキュメントだと言っていいと思う。まだ読んでいないけど<a href="https://elements.polymer-project.org/guides/using-neon-animations">neon-animation</a>も気になっている。確か今策定中のWeb Animationsを使う要素のコレクションだったと思う。</p></paper-card></article><article><paper-card elevation=2><a href="../../2015/11/03.html"><h1>Rubyでの文字列の「長さ」</h1><time pubdate>2015-11-03</time></a><ul class=tags><li><a href="../../tags/ruby.html" rel=tag>Ruby</a></li></ul><p>Rubyでは、文字列（<code class=highlighter-rouge>String</code>）クラスに<a href="http://ref.xaio.jp/ruby/classes/string/length"><code class=highlighter-rouge>length</code></a>というメソッドがあって、これは文字列の長さを返してくれる。「文字列の長さ」というのは一体何なのだ、というのは実は自明ではない（「実は」とか言ってみたけど、みんな、知っている気がするな）。文字の数かも知れないし、バイト（オクテット）の長さかも知れない。Rubyの<code class=highlighter-rouge>String#length</code>の場合は、文字の数を返す。バイト数が欲しければ<a href="http://ref.xaio.jp/ruby/classes/string/bytesize"><code class=highlighter-rouge>bytesize</code></a>メソッドを使う。</p><p>余談だけど、Rubyで文字を扱おうと思ったら、るびまの<a href="http://magazine.rubyist.net/?0025-Ruby19_m17n">Ruby M17N の設計と実装</a>をぜひ読んだほうがいい。</p><p>さて長さに戻って、文字の長さというのは、例えばこういうことだ。</p><div class="language-ruby highlighter-rouge"><pre class=highlight><code><span class="c1"># coding: utf-8</span>
<span class="c1"># ソースコードファイルのエンコーディングをUTF-8とする</span>

<span class="s2">"a"</span><span class="p">.</span><span class="nf">length</span> <span class="c1">#=&gt; 1</span>
<span class="s2">"a"</span><span class="p">.</span><span class="nf">bytesize</span> <span class="c1">#=&gt; 1</span>

<span class="s2">"あいう"</span><span class="p">.</span><span class="nf">length</span> <span class="c1">#=&gt; 3 三文字の文字列</span>
<span class="s2">"あいう"</span><span class="p">.</span><span class="nf">bytesize</span> <span class="c1">#=&gt; 9 ソースコードファイルがUTF-8なので、文字列リテラルもUTF-8になり、バイト数は9になる</span>

<span class="s2">"あいう"</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="s2">"UTF-16LE"</span><span class="p">).</span><span class="nf">length</span> <span class="c1">#=&gt; 3</span>
<span class="s2">"あいう"</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="s2">"UTF-16LE"</span><span class="p">).</span><span class="nf">bytesize</span> <span class="c1">#=&gt; 6</span>

<span class="c1"># UTF-16でエンディアンを明示しない場合は、（ファイルではなく文字列オブジェクト自体に）2バイトのBOMが付く</span>
<span class="s2">"あいう"</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="s2">"UTF-16"</span><span class="p">).</span><span class="nf">length</span> <span class="c1">#=&gt; 4</span>
<span class="s2">"あいう"</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="s2">"UTF-16"</span><span class="p">).</span><span class="nf">bytesize</span> <span class="c1">#=&gt; 8</span>
</code></pre></div><p>（今どき断らなくていいとは思うけど、ここでは1バイトは1オクテット＝8ビット）</p><p>UTF-16にはサロゲートペアという物があって、多くの文字は一文字あたり16ビット（2バイト）なんだけど、サロゲートペアを使って表す文字は一文字表すのに32ビット（4バイト）使う。</p><div class="language-ruby highlighter-rouge"><pre class=highlight><code><span class="s2">"𩸽"</span><span class="p">.</span><span class="nf">bytesize</span> <span class="c1">#=&gt; 4</span>
</code></pre></div><p>それでも、Rubyはこれを「一文字」として数えてくれる。</p><div class="language-ruby highlighter-rouge"><pre class=highlight><code><span class="s2">"𩸽"</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="s1">'UTF-16LE'</span><span class="p">).</span><span class="nf">length</span> <span class="c1">#=&gt; 1</span>
</code></pre></div><p>人間にとってとても分かり易い。</p><p>JavaScriptではこれは「長さ」が2となるらしい（<a href="http://qiita.com/YusukeHirao/items/2f0fb8d5bbb981101be0#iii-ii-%E6%96%87%E5%AD%97%E5%88%97%E9%95%B7%E3%82%92%E6%AD%A3%E3%81%97%E3%81%8F%E5%8F%96%E5%BE%97%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84">JavaScriptでのサロゲートペア文字列のメモ</a>）。16ビットが何個分か、という数え方のようだ。JavaScritpでは内部エンコーディングがUTF-16らしいから、処理系の設計者にとってこれが自然だったんだろう。</p><p>ここまでなら、Rubyは人間に優しい言語ですね、よかったよかった、となる。しかしたまに困ることがある。</p><p>この前気まぐれで、<a href="https://github.com/KitaitiMakoto/nokogiri-xml-range">Nokogiri::XML::Range</a>というRubyGemを作った。これは、ブラウザーのマウスで選択した部分を表したりする時に使う<a href="https://dom.spec.whatwg.org/#ranges">DOM Range</a>という仕様を、<a href="http://www.nokogiri.org/">Nokogiri</a>を使って実装してみた物だ。</p><p>これを書く時に、文字列の「長さ」を扱う必要があった。長さとは一体何なのか、仕様書の中を探していくと</p><blockquote><p>The length attribute must return the number of code units in data.<br/> （length属性はデータのcode unitの数を返す）</p></blockquote><p>という表現に行き着く（<a href="https://dom.spec.whatwg.org/#dom-characterdata-length">https://dom.spec.whatwg.org/#dom-characterdata-length</a>）。</p><p>更に、この「code unit」のリンクを踏むと、</p><blockquote><p>The value of the string token is the sequence of 16 bit unsigned integer code units (hereafter referred to just as code units) corresponding to the UTF-16 encoding of S.<br/> （文字列トークンの値は、文字列SのUTF-16エンコーディングに対応する16ビット符号なし整数のcode unitの列（以後、単にcode unitとする）である）</p></blockquote><p>という表現が現れる（<a href="https://heycam.github.io/webidl/#dfn-code-unit">https://heycam.github.io/webidl/#dfn-code-unit</a>）。ここだけ切り取って翻訳するのは僕には難しかったので、できれば前後まとめて読んでほしいけど、要は「16ビットが何個あるか」を文字列の「長さ」とする、ということだ。UTF-16では多くの場合一文字が16ビットで表現されるので、この長さは直感と一致する。でもさっきの「𩸽（ほっけ、らしい）」の場合は32ビットなので、一文字でも「長さ」は2になる。</p><p>どうもUnicodeか何かの規格でも、「UTF-16 length」という物が定義されていて、ここで言う「長さ」と同様の物らしい。正直あんま調べる気の起きないところなので教えてもらったツイートをそのまま貼る：</p><blockquote class=twitter-tweet lang=ja><p lang=ja dir=ltr><a href="https://twitter.com/KitaitiMakoto">@KitaitiMakoto</a> ですね。サロゲ以外にも合成文字とかもあります。utf-16にエンコードしたときの2バイト単位の長さと考えるば良いかと。</p>&mdash; OE Waku (@wakufactory) <a href="https://twitter.com/wakufactory/status/661340825687752704">2015, 11月 3</a></blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset=utf-8></script><p>Nokogiri::XML::Rangeで扱う対象はNokogiriで扱う対象なので、文字エンコーディングが何になるかは分からない、決め打ちできない。その前提で、途中で「長さ」を扱うために、一旦UTF-16に変換して長さを数える、という処理を入れざるを得なかった。多分、この「長さ」は実際には人間の感じる一文字、つまりRubyの<code class=highlighter-rouge>String#length</code>の値にしても殆どの場合問題ないだろうなと思いつつ、ライブラリーなのでそうではない場合も一応扱えないといけない、ということでパフォーマンスが落ちるの覚悟でこんなことをしないといけないのはもやもやした。</p><p>もう一つ困ったことがある。<a href="http://www.idpf.org/epub/linking/cfi/epub-cfi.html">EPUB CFI</a>の仕様でも、文字を数えるのに「UTF-16 length」を扱うことだ（上のツイートの「UTF-16 length」というのはこの仕様の表現を使った）。</p><p>EPUB CFIを非常に大雑把に説明すると、「EPUBファイルの中のある一点、もしくはある範囲を表現する物」だ。EPUBの読む部分は多くの場合XHTMLになっているので、テキスト中のある一点（一文字）を指す場合には、「DOMツリー中の親要素までのパス＋文字オフセット」という物を使うことになる。例えばこういう風な見た目をしている。</p><div class=highlighter-rouge><pre class=highlight><code>book.epub#epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/3:10)
</code></pre></div><p>全体の意味を知りたい場合は仕様なり解説記事なりを読んでほしいけど、最後の「<code class=highlighter-rouge>:10</code>」というのが文字オフセットの部分だ。対象テキストノードの10文字目、ということになる。「文字目」と言ったが実際にはUTF-16 lengthなので、人間的な感覚の文字数とは限らない。</p><p>EPUB CFIは表現の仕様であって、用途について決まった物があるわけではないけど、例えば、ウェブページのURIのフラグメントのように、文書の途中にリンクを貼る場合に使うことができる。このEPUB CFIを渡してやると、EPUBリーダーがその部分を頭出しして開いてくれる、というのは普通に期待される使い方だ（実際、<a href="http://bibi.epub.link/">BiB/i</a>というEPUBリーダーはこれに対応している）。</p><p>JavaScriptでこれを扱うなら（或いはJavaも？）簡単なんだろうけど、Rubyだとやはり不必要に思われる処理を入れないといけない。せっかく人間に優しく出来ているのに、仕様のほうがそうなってなかった（いや、UTF-16で暮らしてる人にはフレンドリーなんだろうけどね）。まあ技術文書なので、そういうもんなんだろうけど、愚痴りたくもなりますね。</p></paper-card></article><footer><ul><li class=next><a href="../17/" rel=next><paper-button raised>前3日分</paper-button></a></li><li class=prev><a href="../19/" rel=prev><paper-button raised>次3日分</paper-button></a></li></ul><paper-card><blog-search url="https://search.apehuci.kitaitimakoto.net/d" base=/apehuci/ table=Apehuci debounce-duration=300></blog-search></paper-card><paper-card> &copy; <a class=copy href="https://twitter.com/KitaitiMakoto">北市真</a></paper-card></footer></app-header-layout></main><script async="" src="//platform.twitter.com/widgets.js" charset=utf-8></script></body></html>