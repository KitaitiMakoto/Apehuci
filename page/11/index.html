<!DOCTYPE html><html><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta charset=utf-8><meta name=description content="北市真の日記"><meta content="width=device-width,initial-scale=1.0" name=viewport><title>アペフチ</title><script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script><link href="../../components/elements.vulcanized.html" rel=import /><link rel=alternate type="application/atom+xml" title="アペフチ" href="../../recent-days.atom"/><link href="../../bower_components/sanitize-css/sanitize.css" rel=stylesheet /><link href="../../stylesheets/highlight-81ca03d6.css" rel=stylesheet /><script src="../../javascripts/all-d7c52391.js"></script><link href="../../favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="../../images/favicon-8d71db77.png" rel=icon type="image/png" size=60x60 /><link href="/apehuci/manifest.json" rel=manifest><meta name=theme-color content="#b71c1c"><meta name=og:description content="北市真の日記"><meta name=og:title content="アペフチ"><meta name=twitter:card content=summary><meta name=twitter:site content=@KitaitiMakoto><meta name=twitter:image content="https://kitaitimakoto.github.io/apehuci/images/icon-bbe8ac52.png"><meta name=robots content="noindex,follow"></head><body class="page page_11 page_11_index"><blog-router base-regex="^/apehuci/"></blog-router><main><app-header-layout><app-header fixed condenses effects=waterfall slot=header><app-toolbar></app-toolbar><app-toolbar sticky><h1 class=site-title><a href="../../">アペフチ</a></h1></app-toolbar></app-header><article><paper-card elevation=2><a href="../../2016/02/02.html"><h1>Sendagaya.rb #135</h1><time pubdate>2016-02-02</time></a><ul class=tags><li><a href="../../tags/ruby.html" rel=tag>Ruby</a></li><li><a href="../../tags/ruby-on-rails.html" rel=tag>Ruby on Rails</a></li></ul><p><a href="https://sendagayarb.doorkeeper.jp/events/38208">Sendagaya.rb #135</a>に行って来た。今日も前半は『<a href="https://www.oreilly.co.jp/books/9784873117430/">メタプログラミングRuby 第2版</a>』を読んで、後半はRails 5のチェンジログから<a href="https://github.com/rails/rails/blob/v5.0.0.beta1/activerecord/CHANGELOG.md">Active Record 5.0.0.beta1のチェンジログ</a>を眺めていた。</p><h2 id=ruby-refinements>メタプログラミングRuby Refinements</h2><p>今日は「2.4.2 メソッドの実行」から「2.4.3 Refinements」まで。</p><p>メソッドの実行では他の言語から来ると<code class=highlighter-rouge>private</code>とかに戸惑うよねとか、<code class=highlighter-rouge>protected</code>って何に使うんだろうねという話をした。</p><p>お次はいよいよ<a href="http://magazine.rubyist.net/?0041-200Special-refinement">Refinements</a>。</p><div class="language-ruby highlighter-rouge"><pre class=highlight><code><span class="k">class</span> <span class="nc">MyClass</span>
  <span class="k">def</span> <span class="nf">my_method</span>
    <span class="s2">"original my_method"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">anothor_method</span>
    <span class="n">my_method</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">MyClassRefinements</span>
  <span class="n">refine</span> <span class="no">MyClass</span> <span class="k">do</span>
    <span class="k">def</span> <span class="nf">my_method</span>
      <span class="s2">"refined my_method"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">using</span> <span class="no">MyClassRefinements</span>
<span class="no">MyClass</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">my_method</span>      <span class="c1"># =&gt; "refined my_method"</span>
<span class="no">MyClass</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">another_method</span> <span class="c1"># =&gt; "original my_method"</span>
</code></pre></div><p>この最後の行は驚かないだろうか。僕は驚いた。</p><p>この挙動を本では</p><blockquote><p>Refinementsが有効になっているコードは、（略）インクルードやプリペンドしたモジュールのコードよりも優先される。</p></blockquote><p>と説明している。しかしこれだけで、メソッド探索の順番を覚えられるだろうか。<a href="https://twitter.com/tkawa">@tkawa</a>さんの説明が素晴らしかった。</p><ol><li>クラスやインクルードやプリペンドを考慮するより先に、まずRefinementsを探す</li><li>次に通常のメソッド探索手順に従って、プリペンドされた物、インクルードした物、特異クラス、クラス……とメソッドを探す</li></ol><p>ということだ。上の例で言うと、まず<code class=highlighter-rouge>my_methodを呼ぶ場合</code></p><ol><li>Refinementsを探す</li><li><code class=highlighter-rouge>MyClassRefinements</code>が見付かる</li><li><code class=highlighter-rouge>my_method</code>が定義されている</li><li><code class=highlighter-rouge>MyClassRefinements#my_method</code>を呼ぶ</li></ol><p>で、結果は<code class=highlighter-rouge>"refined my_method"</code>になる。一方<code class=highlighter-rouge>another_method</code>は</p><ol><li>Refinementsを探す</li><li><code class=highlighter-rouge>MyClassRefinements</code>が見付かる</li><li><code class=highlighter-rouge>another_method</code>は定義されていない</li><li>Refinementsの探索は終わり、今後二度と探索されない</li><li>プリペンドされたモジュールやインクルードされたモジュールを探すが、ない</li><li>クラスを見る</li><li><code class=highlighter-rouge>MyClass</code>である</li><li><code class=highlighter-rouge>another_method</code>が定義されている</li><li><code class=highlighter-rouge>another_method</code>を実行する</li><li><code class=highlighter-rouge>my_method</code>が呼ばれている</li><li>Refinementsの探索は終わっているので、クラスの<code class=highlighter-rouge>my_method</code>が見付かる</li><li><code class=highlighter-rouge>MyClass#my_method</code>を実行する</li></ol><p>ということで、結果が<code class=highlighter-rouge>"original my_method"</code>になる、というわけだ。</p><p>子の説明を聞いて僕は「あ。」と声が漏れるくらい腹に落ちた。</p><h2 id=active-record-500beta1>Active Record 5.0.0.beta1チェンジログ</h2><p>その後もちょいちょいRefinementsと遊んでからは<a href="https://github.com/rails/rails/blob/v5.0.0.beta1/activerecord/CHANGELOG.md">Active Record 5.0.0.beta1のチェンジログ</a>をざっと流しながら気になった所で止めて、あーだこーだ言っていた。結構RDBMSの個別機能に対応していたり、細かなユースケースを拾ったりしていて、「Active Recordは基本は既に成熟しているんだろうなあ」という感想を持った。</p><p>次回は『メタプログラミングRuby』読むほか、fukajunさんがElectronについての発表をしたいということなのでそれは聞けるはずだ。あとはその場で決まるんだろう。その場で決まるので、聞きたいことを持って行けば、聞けると思う。</p><p>次回分もすぐさまイベントが作られて、申し込める。<br/><a href="https://sendagayarb.doorkeeper.jp/events/38655">https://sendagayarb.doorkeeper.jp/events/38655</a></p></paper-card></article><article><paper-card elevation=2><a href="../../2016/01/29.html"><h1>ノーマライズと形態素解析</h1><time pubdate>2016-01-29</time></a><ul class=tags><li><a href="../../tags/.html" rel=tag>全文検索</a></li><li><a href="../../tags/groonga.html" rel=tag>Groonga</a></li><li><a href="../../tags/.html" rel=tag>形態素解析</a></li></ul><p><a href="https://groonga.doorkeeper.jp/events/37647">Groongaで学ぶ全文検索 2016-01-29</a>に行って来た。今日は濃かった。その分面白かった。</p><p>まずノーマライザーの話をして、その後形態素解析の話をした。</p><h2 id=section>ノーマライザー</h2><p>ノーマライザーはノーマライズする物。ノーマライズは、半角「ｶﾚｰ」と全角「カレー」、ひらがな「りんご」とかたかな「リンゴ」など、厳密には違う物を同じ物に寄せるという処理。どういう基準でノーマライズするかというのは色々あって、その色々ごとにノーマライザーの種類がある。</p><p>インデックスを作る時、インデックスのキーにノーマライズした物を選んでおくと、例えば「りんご」で検索した時に、「りんご」を含む文書と「リンゴ」を含む文書の両方を返すことができる。これがノーマライザーを使う理由。</p><p>ただ、この状況下で「リンゴ」で検索すると、インデックスのキーワードには「りんご」しかないので、何もヒットしない（「リンゴ」というキーワードはインデックスを作る時にノーマライズされて「りんご」になっているから、入っていない）。だから、検索時にクエリーの方もノーマライズする。この時にはインデックス作成時と同じノーマライザーを使わないと、キーワードの集合が変わるので、いけない。</p><p>（面白い質疑応答二つあった、後で書く。かも。）</p><h2 id=section-1>形態素解析</h2><p>形態素解析は、文などを形態素に分ける処理。形態素が何かは各自調べられたい。迂闊なことを言えない。日本語の文を構成する、意味的に分割できる一番小さな単位、とかそんな感じ。全文検索では、インデックスのキーワードをどのように選ぶかというやり方の一つとして、形態素解析器を使う（他にN-gramがあるのは以前書いた通り：<a href="../../2015/11/20.html">日本語文書の全文検索</a>）。</p><p>例えばクエリーの中の「りんご」と「リンゴ」を同一視するには、文字単位で見ていって、かたかなを見付ける度に全部ひらがなにしていけばいい。こういうノーマライズは文字単位で処理すればできる。が、「PC」で検索した時に「パソコン」を含む文書を返す、二つを同一視するにはこの方法では不可能。「パソコン」を見つけたら「PC」にする必要がある。この時に</p><ul><li>「パソコン」が一つの単位になるように、クエリーを分割する方法（形態素に分割する方法）、「パソ」みたいに「パソコン」より細かく分割しないし、「パソコンを」みたいに他の語とくっついた形で大きな粒度で分割しない方法。</li><li>「パソコン」と「PC」は同じ物だ、という日本語の知識（扱うアプリケーションによる。同じ物と扱いたくないアプリケーションもあるだろう）</li></ul><p>の知識が必要になる。</p><p>前者が形態素解析と呼ばれる処理。形態素解析器は「『パソコン』というのは名詞である」「『で』というのは助詞である」「『で』は文の最初には現れない」といった知識（辞書）を持っている。この知識を元に文を解析して、日本語としてありそうな切り方を何パターンか出す。その中の一番ありそうな物を結果として返す（それを全文検索エンジンが使う）。</p><p>ところで、どのように切るか、というのは、ドメインによって変わる。新聞で使われる言葉、ツイッターで使われる言葉、若者の言葉、年寄りの言葉……。 アプリケーションが扱うドメインが分かっているなら、一般的（？）な切り方でなく、それぞれに適した切り方ができるはずだ。この「それぞれに適した」は、それぞれ用の辞書を使うことで対応する（形態素解析器自体は変えない）。時代とともに検索結果が古びてきたようだと、辞書を新しくする必要も出てくるだろう。</p><p>辞書を新しくするということは、インデックスのキーワードの選び方が変わるということだから、その時にはインデックスを作り直す必要がある。</p><p>後者、単語（形態素）の同一視は、ノーマライズの前のクエリー展開というフェイズでやっている。そこは辞書を元にクエリーを見て、</p><div class=highlighter-rouge><pre class=highlight><code>「パソコンほしい」 OR 「PCほしい」 OR 「パソコン欲しい」 OR 「PC欲しい」
</code></pre></div><p>みたいなクエリーに変換して検索エンジンに投げている。</p><p>「パソコン」と「PC」を同一視するには、形態素解析の結果が欲しいところだがクエリー展開はその前なので、ここは独自に頑張ったりする。その場合は「（二重に同じ処理をすることになのるで）<del>トークナイズ</del><ins>ノーマライズ（勉強会中に発表し、直してもらった）</ins>はしないように」といった仕様上の注意が生まれる。</p><p>今回は話題が広くて、また勉強会中に公開したいという制約とでまとめられないがこんな感じだった。あとで追記するかも知れない。</p></paper-card></article><article><paper-card elevation=2><a href="../../2016/01/26.html"><h1>『APIデザインケーススタディ』を読んだ</h1><time pubdate>2016-01-26</time></a><ul class=tags><li><a href="../../tags/ruby.html" rel=tag>Ruby</a></li></ul><p>ようやく『<a href="https://gihyo.jp/dp/ebook/2015/978-4-7741-7879-0">APIデザインケーススタディ</a>』を読み終えた。デザインの本なのだけど、僕はRubyの様々な組み込み・標準添付ライブラリーの解説書、またはエッセイとして、主に読んだ。楽しい時間で、読み終わって寂しい。</p><div class=booklog_html><table><tr><td class=booklog_html_image><a href="https://gihyo.jp/dp/ebook/2015/978-4-7741-7879-0" target=_blank><img src="http://image.gihyo.co.jp/assets/images/gdp/2015/978-4-7741-7879-0.jpg" width=92 height=130 style="border:0;border-radius:0;"/></a></td><td class=booklog_html_info style="padding-left:20px;"><div class=booklog_html_title style="margin-bottom:10px;font-size:14px;font-weight:bold;"><a href="https://gihyo.jp/dp/ebook/2015/978-4-7741-7879-0" target=_blank>APIデザインケーススタディ ――Rubyの実例から学ぶ。問題に即したデザインと普遍の考え方</a></div><div style="margin-bottom:10px;"><div class=booklog_html_author style="margin-bottom:15px;font-size:12px;;line-height:1.2em">著者 : <a href="http://booklog.jp/author/%E7%94%B0%E4%B8%AD%E5%93%B2%E8%91%97" target=_blank>田中哲著</a></div><div class=booklog_html_manufacturer style="margin-bottom:5px;font-size:12px;;line-height:1.2em">株式会社技術評論社</div><div class=booklog_html_release style="font-size:12px;;line-height:1.2em">発売日 : 2015-12-16</div></div><div class=booklog_html_link_amazon><a href="http://booklog.jp/item/13/9784774178790" style="font-size:12px;" target=_blank>ブクログでレビューを見る»</a></div></td></tr></table></div><p>本当は25日に読み終わったのだけど、昨日はSendagaya.rbのことを書いたので、話題を分けるために今日にした。こういう時、<a href="http://www.tdiary.org/">tDiary</a>が恋しくなる。日記の為のソフトウェアだから、一日に複数の話題を書くことが、自然にできる。</p><p>この本は「I/O」「ソケット」「プロセス」「時刻」「数、文字列」の五章で構成されている。個人的にこれを</p><ul><li>OSとの間を埋める（「I/O」、「ソケット」、「プロセス」）</li><li>人間社会との間を埋める（「時刻」）</li><li>その他（「数、文字列」）</li></ul><p>と捉えた。</p><h2 id=os>OSとの間を埋める</h2><p>RubyのI/Oやプロセスなどに関するクラスは、システムコールやglibcの関数を、インターフェイスは模倣して、内部では呼び出すのを原則としてデザインされている。その中でも、そのままglibcからRubyに移植せず、敢えて異なるインターフェイスや動作にしたほうがいい所があったのでそうした、や、ユースケースを考えるとメソッドを追加したほうがいいからそうした、などの事例が紹介されている。それぞれに調査結果、考察、決断が述べられていて、単なるカタログにはなっていなくてケーススタディする内容があり、面白い。</p><p>僕はRubyのユーザーではあるけれど、Cは書けない。拡張ライブラリーは使う一方だし、OSのシステムコールなども直接触ることはまずない。<a href="http://docs.ruby-lang.org/ja/2.3.0/method/IO/i/read_nonblock.html">IO#read_nonblock</a>なども、使うことはあってリファレンスマニュアルは読むけど、そこに書いていることで満足して、それでも不明なところは（Rubyプログラムを）動かして確認してから使っていた。この本では、そういった部分のOS側の話なども解説した上で、Rubyではどうしたかと話してくれるので、デザインだけでなく、APIその物の勉強にもなる。「自分が触っている部分の一つ下のレイヤーも理解しておくべきだ」とはよく言われることで、でも中々実践は難しい、その部分を行えるので助かる。</p><p>また、余談になるが、ノンブロッキングI/Oという言葉は非常によく聞くし、一応、<a href="http://rubyeventmachine.com/">EventMachine</a>や<a href="https://nodejs.org/en/">Node.js</a>などで使えてはいるつもりだ。でも、下のレイヤーでは、ファイルディスクリプターにブロッキングモードとノンブロッキングモードがあって、ノンブロッキングモードの時にアクセスして読み取り可能でなければこういうエラーになって、という仕組みになっていたことは全く知らなかった。この知識が、直後に読み始めた『<a href="https://gihyo.jp/dp/ebook/2016/978-4-7741-7936-0">nginx実践入門</a>』の最初のほうで活きたので思わず顔がにやけた。</p><h2 id=section>人間社会との間を埋める</h2><p>第4章は時刻の話。ここはもう、人間側の都合に合わせる話が圧巻。</p><p>閏秒があるから将来の日時を正確に表すことは不可能、というのは序の口で、日本にいると、UTCにタイムゾーンオフセットを足せばいいんでしょ？　くらいに考えてしまうかも知れないけど夏時間があったらそうはいかない。夏時間、いつから夏時間で、いつまで夏時間か、どのように決まるのか、知っていますか？　僕は知らなかった。「毎年これこれの月のこれこれの曜日」みたいに決まっているのはいい方で、太陰暦に従うとか、その年にならないと政府が決めないとか、ほんと色々ある。夏時間の切り替わりのタイミングでは、存在しない日時や二重に存在する日時が存在するので、日時の扱いは慎重さが必要になってくる。</p><h2 id=section-1>その他</h2><p>ここは数値関連の色々な話。ここまで読んでいれば、APIデザインのパターンに少しは慣れているので、なるほどなるほどとさくさく進む章だった。</p><p>「終わりに」で</p><blockquote><p>ところで、意識的に使いやすさをデザインするにあたって、具体例と並んで存在して欲しいのは、使いやすさの理論です。理論があれば、個々の具体例がどのような理屈で使いやすさを実現しているか、理解しやすくなりますし、目の前の問題を解決するライブラリをどうデザインするのが良いのか、という見通しを与えてくれるでしょう。さらには、使いにくさという問題を発見することにも役に立つかもしれません。</p></blockquote><blockquote><p>残念なことに、今のところ、そのような理論で満足できるものはなさそうです。</p></blockquote><p>ということが述べられていた。何気ない文のようだが、最後まで読んだ所で「意識的に使いやすさをデザイン」と言われると、とても重みがある。</p></paper-card></article><footer><ul><li class=next><a href="../10/" rel=next><paper-button raised>前3日分</paper-button></a></li><li class=prev><a href="../12/" rel=prev><paper-button raised>次3日分</paper-button></a></li></ul><paper-card><blog-search url="https://search.apehuci.kitaitimakoto.net/d" base=/apehuci/ table=Apehuci debounce-duration=300></blog-search></paper-card><paper-card> &copy; <a class=copy href="https://twitter.com/KitaitiMakoto">北市真</a></paper-card></footer></app-header-layout></main><script async="" src="//platform.twitter.com/widgets.js" charset=utf-8></script></body></html>